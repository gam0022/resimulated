!function(n){var e={};function t(i){if(e[i])return e[i].exports;var o=e[i]={i:i,l:!1,exports:{}};return n[i].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=n,t.c=e,t.d=function(n,e,i){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:i})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)t.d(i,o,function(e){return n[e]}.bind(null,o));return i},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=12)}([function(n,e,t){"use strict";t.r(e),e.default="#version 300 es\n\ninvariant gl_Position;\nin vec2 vert2d;\n\nvoid main(void) { gl_Position = vec4(vert2d, 0, 1); }\n"},function(n,e,t){"use strict";t.r(e),e.default="#version 300 es\nprecision highp float;\nprecision highp int;\nprecision mediump sampler3D;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\n\nout vec4 outColor;\nvoid main(void) {\n    vec4 c;\n    mainImage(c, gl_FragCoord.xy);\n    outColor = c;\n}\n\n// consts\nconst float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\nconst float PIH = 1.57079632679;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nuniform vec3 iResolution;\nuniform float iTime;\nuniform sampler2D iPrevPass;\nuniform sampler2D iTextTexture;\n\n// https://www.shadertoy.com/view/3tX3R4\nfloat clamp2(float x, float min, float max) { return (min < max) ? clamp(x, min, max) : clamp(x, max, min); }\nfloat remap(float val, float im, float ix, float om, float ox) { return clamp2(om + (val - im) * (ox - om) / (ix - im), om, ox); }\nfloat remapFrom(float val, float im, float ix) { return remap(val, im, ix, 0.0, 1.0); }  // TODO: optimize\nfloat remapTo(float val, float om, float ox) { return remap(val, 0.0, 1.0, om, ox); }    // TODO: optimize\nfloat easeInOutCubic(float t) { return t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0; }\n\n// noise\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash23(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// https://www.shadertoy.com/view/4dlGW2\n// Tileable Noise\nfloat hashScale(in vec2 p, in float scale) {\n    // This is tiling part, adjusts with the scale...\n    p = mod(p, scale);\n    return fract(sin(dot(p, vec2(27.16898, 38.90563))) * 5151.5473453);\n}\n\nfloat noise(in vec2 p, in float scale) {\n    vec2 f;\n\n    p *= scale;\n\n    f = fract(p);  // Separate integer from fractional\n    p = floor(p);\n\n    f = f * f * (3.0 - 2.0 * f);  // Cosine interpolation approximation\n\n    float res = mix(mix(hashScale(p, scale), hashScale(p + vec2(1.0, 0.0), scale), f.x), mix(hashScale(p + vec2(0.0, 1.0), scale), hashScale(p + vec2(1.0, 1.0), scale), f.x), f.y);\n    return res;\n}\n\nfloat fbm(in vec2 p, float scale) {\n    float f = 0.0;\n\n    p = mod(p, scale);\n    float amp = 0.6;\n\n    for (int i = 0; i < 5; i++) {\n        f += noise(p, scale) * amp;\n        amp *= .5;\n        // Scale must be multiplied by an integer value...\n        scale *= 2.;\n    }\n\n    return f;\n}\n\n// https://www.shadertoy.com/view/lsf3WH\n// Noise - value - 2D by iq\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), hash12(i + vec2(1.0, 0.0)), u.x), mix(hash12(i + vec2(0.0, 1.0)), hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(in vec2 uv) {\n    float f = 0.0;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    f = 0.5000 * noise(uv);\n    uv = m * uv;\n    f += 0.2500 * noise(uv);\n    uv = m * uv;\n    f += 0.1250 * noise(uv);\n    uv = m * uv;\n    f += 0.0625 * noise(uv);\n    uv = m * uv;\n    return f;\n}\n\nvec3 tap4(sampler2D tex, vec2 uv, vec2 texelSize) {\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\n\n    vec3 s;\n    s = texture(tex, uv + d.xy).rgb;\n    s += texture(tex, uv + d.zy).rgb;\n    s += texture(tex, uv + d.xw).rgb;\n    s += texture(tex, uv + d.zw).rgb;\n\n    return s * (1.0 / 4.0);\n}\n\nvec2 textUv(vec2 uv, float id, vec2 p, float scale) {\n    uv -= p;\n    uv /= scale;\n\n    float offset = 128.0 / 4096.0;\n    float aspect = 2048.0 / 4096.0;\n    uv.x = 0.5 + 0.5 * uv.x;\n    uv.y = 0.5 - 0.5 * (aspect * uv.y + 1.0 - offset);\n    uv.y = clamp(uv.y + offset * id, offset * id, offset * (id + 1.0));\n\n    return uv;\n}\n\n// Color\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, saturate(p - K.xxx), c.y);\n}\n\n#define BPM 140.0\n#define beat (iTime * BPM / 60.0)\n"},function(n,e,t){"use strict";t.r(e),e.default="uniform float gSceneId;   // 0 0 2 scene\nuniform float gSceneEps;  // 0.002 0.00001 0.01\n#define SCENE_MANDEL 0.0\n#define SCENE_UNIVERSE 1.0\n\nuniform float gCameraEyeX;     // 0 -100 100 camera\nuniform float gCameraEyeY;     // 2.8 -100 100\nuniform float gCameraEyeZ;     // -8 -100 100\nuniform float gCameraTargetX;  // 0 -100 100\nuniform float gCameraTargetY;  // 2.75 -100 100\nuniform float gCameraTargetZ;  // 0 -100 100\nuniform float gCameraFov;      // 13 0 180\n\nuniform float gMandelboxScale;   // 2.7 1 5 mandel\nuniform float gMandelboxRepeat;  // 10 1 100\nuniform float gEdgeEps;          // 0.0005 0.0001 0.01\nuniform float gEdgePower;        // 1 0.1 10\nuniform float gBaseColor;        // 0.5\nuniform float gRoughness;        // 0.1\nuniform float gMetallic;         // 0.4\n\n// consts\nconst float INF = 1e+10;\nconst float OFFSET = 0.1;\n\n// ray\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// camera\nstruct Camera {\n    vec3 eye, target;\n    vec3 forward, right, up;\n};\n\nRay cameraShootRay(Camera c, vec2 uv) {\n    c.forward = normalize(c.target - c.eye);\n    c.right = normalize(cross(c.forward, c.up));\n    c.up = normalize(cross(c.right, c.forward));\n\n    Ray r;\n    r.origin = c.eye;\n    r.direction = normalize(uv.x * c.right + uv.y * c.up + c.forward / tan(gCameraFov / 360.0 * PI));\n\n    return r;\n}\n\n// intersection\nstruct Intersection {\n    bool hit;\n    vec3 position;\n    float distance;\n    vec3 normal;\n    vec2 uv;\n    float count;\n\n    vec3 baseColor;\n    float roughness;\n    float reflectance;\n    float metallic;\n    vec3 emission;\n\n    bool transparent;\n    float refractiveIndex;\n\n    vec3 color;\n};\n\n// util\n#define calcNormal(p, dFunc, eps)                                                                                                                                                 \\\n    normalize(vec2(eps, -eps).xyy *dFunc(p + vec2(eps, -eps).xyy) + vec2(eps, -eps).yyx * dFunc(p + vec2(eps, -eps).yyx) + vec2(eps, -eps).yxy * dFunc(p + vec2(eps, -eps).yxy) + \\\n              vec2(eps, -eps).xxx * dFunc(p + vec2(eps, -eps).xxx))\n\n// Distance Functions\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nmat2 rotate(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat dMandelFast(vec3 p, float scale, int n) {\n    vec4 q0 = vec4(p, 1.0);\n    vec4 q = q0;\n\n    for (int i = 0; i < n; i++) {\n        // q.xz = mul(rotate(_MandelRotateXZ), q.xz);\n        q.xyz = clamp(q.xyz, -1.0, 1.0) * 2.0 - q.xyz;\n        q = q * scale / clamp(dot(q.xyz, q.xyz), 0.3, 1.0) + q0;\n    }\n\n    return length(q.xyz) / abs(q.w);\n}\n\nvec2 foldRotate(vec2 p, float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = TAU / s;\n    a = floor(a / n) * n;\n    p = rotate(a) * p;\n    return p;\n}\n\nuniform float gFoldRotate;  // 1 0 20\n\nfloat dStage(vec3 p) {\n    float b = max(beat - 128.0, 0.0) + (p.z + 10.0);\n    p.xy = foldRotate(p.xy, gFoldRotate);\n    return dMandelFast(p, gMandelboxScale, int(gMandelboxRepeat));\n}\n\nuniform float gBallZ;               // 0 -100 100 ball\nuniform float gBallRadius;          // 0 0 0.2\nuniform float gLogoIntensity;       // 0 0 4\nuniform float gBallDistortion;      // 0.0 0 0.1\nuniform float gBallDistortionFreq;  // 30 0 100\n\nfloat dBall(vec3 p) {\n    return sdSphere(p - vec3(0, 0, gBallZ), gBallRadius) - gBallDistortion * sin(gBallDistortionFreq * p.x + beat) * sin(gBallDistortionFreq * p.y + beat) * sin(gBallDistortionFreq * p.z + beat);\n}\n\nfloat map(vec3 p) {\n    float d = dStage(p);\n\n    if (gBallRadius > 0.0) {\n        d = min(d, dBall(p));\n    }\n\n    return d;\n}\n\n// https://www.shadertoy.com/view/lttGDn\nfloat calcEdge(vec3 p) {\n    float edge = 0.0;\n    vec2 e = vec2(gEdgeEps, 0);\n\n    // Take some distance function measurements from either side of the hit\n    // point on all three axes.\n    float d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n    float d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n    float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    float d = map(p) * 2.;  // The hit point itself - Doubled to cut down on\n                            // calculations. See below.\n\n    // Edges - Take a geometry measurement from either side of the hit point.\n    // Average them, then see how much the value differs from the hit point\n    // itself. Do this for X, Y and Z directions. Here, the sum is used for the\n    // overall difference, but there are other ways. Note that it's mainly sharp\n    // surface curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    // edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); //\n    // Etc.\n\n    // Once you have an edge value, it needs to normalized, and smoothed if\n    // possible. How you do that is up to you. This is what I came up with for\n    // now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge / e.x * 2.));\n\n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return edge;\n}\n\n// Thanks https://shadertoy.com/view/ttsGR4\nfloat revisionLogo(vec2 p, float rot) {\n    int[] pat = int[](0, ~0, 0x7C, 0xC0F03C00, 0xF7FBFF01, ~0, 0, 0x8320D39F, ~0, 0x1F0010, 0);\n    int r = clamp(int(20. * length(p)), 0, 10);\n    return float(pat[r] >> int(5.1 * atan(p.y, p.x) + 16. + (hash11(float(r * 1231)) - 0.5) * rot) & 1);\n}\n\nuniform float gEmissiveIntensity;     // 6.0 0 20 emissive\nuniform float gEmissiveSpeed;         // 1 0 2\nuniform float gEmissiveHue;           // 0.33947042613522904 0 1\nuniform float gEmissiveHueShiftBeat;  // 0 0 1\nuniform float gEmissiveHueShiftZ;     // 0 0 1\nuniform float gEmissiveHueShiftXY;    // 0 0 1\n\nuniform float gF0;                    // 0.95 0 1 lighting\nuniform float gCameraLightIntensity;  // 1 0 10\n\nfloat fresnelSchlick(float f0, float cosTheta) { return f0 + (1.0 - f0) * pow((1.0 - cosTheta), 5.0); }\n\nvoid intersectObjects(inout Intersection intersection, inout Ray ray) {\n    float d;\n    float distance = 0.0;\n    vec3 p = ray.origin;\n    float eps;\n\n    for (float i = 0.0; i < 300.0; i++) {\n        d = abs(map(p));\n        distance += d;\n        p = ray.origin + distance * ray.direction;\n        intersection.count = i;\n        eps = gSceneEps * distance;\n        if (abs(d) < eps) break;\n    }\n\n    if (distance < intersection.distance) {\n        intersection.distance = distance;\n        intersection.hit = true;\n        intersection.position = p;\n        intersection.normal = calcNormal(p, map, gSceneEps);\n\n        if (gBallRadius > 0.0 && abs(dBall(p)) < eps) {\n            intersection.baseColor = vec3(0.0);\n            intersection.roughness = 0.0;\n            intersection.metallic = 1.0;\n            intersection.emission = vec3(0.0);\n            intersection.transparent = false;\n            intersection.refractiveIndex = 1.2;\n            intersection.reflectance = 1.0;\n\n            if (gLogoIntensity > 0.0) {\n                float b = beat - 160.0;\n                float r = remapFrom(b, 0.0, 7.0);\n                r = r - 1.0;\n                intersection.emission = vec3(gLogoIntensity) * revisionLogo(intersection.normal.xy * 0.6, 8.0 * r);\n            }\n        } else {\n            intersection.baseColor = vec3(gBaseColor);\n            intersection.roughness = gRoughness;\n            intersection.metallic = gMetallic;\n\n            float edge = calcEdge(p);\n            float hue = gEmissiveHue + gEmissiveHueShiftZ * p.z + gEmissiveHueShiftXY * length(p.xy) + gEmissiveHueShiftBeat * beat;\n            intersection.emission = gEmissiveIntensity * hsv2rgb(vec3(hue, 0.8, 1.0)) * pow(edge, gEdgePower) * saturate(cos(beat * gEmissiveSpeed * TAU - mod(0.5 * intersection.position.z, TAU)));\n\n            intersection.transparent = false;\n            intersection.reflectance = 0.0;\n        }\n    }\n}\n\nvoid intersectScene(inout Intersection intersection, inout Ray ray) {\n    intersection.distance = INF;\n    intersectObjects(intersection, ray);\n}\n\n#define FLT_EPS 5.960464478e-8\n\nfloat roughnessToExponent(float roughness) { return clamp(2.0 * (1.0 / (roughness * roughness)) - 2.0, FLT_EPS, 1.0 / FLT_EPS); }\n\nvec3 evalPointLight(inout Intersection i, vec3 v, vec3 lp, vec3 radiance) {\n    vec3 n = i.normal;\n    vec3 p = i.position;\n    vec3 ref = mix(vec3(0.04), i.baseColor, i.metallic);\n\n    vec3 l = lp - p;\n    float len = length(l);\n    l /= len;\n\n    vec3 h = normalize(l + v);\n\n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), i.metallic) * i.baseColor / PI;\n    float m = roughnessToExponent(i.roughness);\n    vec3 specular = ref * pow(max(0.0, dot(n, h)), m) * (m + 2.0) / (8.0 * PI);\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n)) / (len * len);\n}\n\nvec3 evalDirectionalLight(inout Intersection i, vec3 v, vec3 lightDir, vec3 radiance) {\n    vec3 n = i.normal;\n    vec3 p = i.position;\n    vec3 ref = mix(vec3(0.04), i.baseColor, i.metallic);\n\n    vec3 l = lightDir;\n    vec3 h = normalize(l + v);\n\n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), i.metallic) * i.baseColor / PI;\n    float m = roughnessToExponent(i.roughness);\n    vec3 specular = ref * pow(max(0.0, dot(n, h)), m) * (m + 2.0) / (8.0 * PI);\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n));\n}\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat fractal(vec3 p, int n) {\n    float strength = 7.0;\n    float accum = 0.25;\n    float prev = 0.;\n    float tw = 0.;\n    for (int i = 0; i < n; i++) {\n        float mag = dot(p, p);\n        p = abs(p) / mag + vec3(-.5, -.4, -1.5);\n        float w = exp(-float(i) / 7.);\n        accum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n        tw += w;\n        prev = mag;\n    }\n    return max(0., 5. * accum / tw - .7);\n}\n\nvoid calcRadiance(inout Intersection intersection, inout Ray ray) {\n    intersection.hit = false;\n    intersectScene(intersection, ray);\n\n    if (intersection.hit) {\n        intersection.color = intersection.emission;\n        intersection.color += evalPointLight(intersection, -ray.direction, vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ), gCameraLightIntensity * vec3(80.0, 80.0, 100.0));\n        // intersection.color += evalPointLight(intersection, -ray.direction, vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ + 4.0), vec3(0.0));\n\n        vec3 sunColor = vec3(2.0, 1.0, 1.0);\n        intersection.color += evalDirectionalLight(intersection, -ray.direction, vec3(-0.48666426339228763, 0.8111071056538127, 0.3244428422615251), sunColor);\n\n        // fog\n        // intersection.color = mix(intersection.color, vec3(0.6),\n        //                         1.0 - exp(-0.0001 * intersection.distance *\n        //                         intersection.distance *\n        //                         intersection.distance));\n    } else {\n        intersection.color = vec3(0.01);\n    }\n}\n\nuniform float gShockDistortion;    // 0 0 1 distortion\nuniform float gExplodeDistortion;  // 0 0 1\n\nvec2 distortion(vec2 uv) {\n    float l = length(uv);\n    // uv += 1.5 * uv * sin(l + beat * PIH);\n\n    uv += -gShockDistortion * uv * cos(l);\n\n    float explode = 30.0 * gExplodeDistortion * exp(-2.0 * l);\n    explode = mix(explode, 2.0 * sin(l + 10.0 * gExplodeDistortion), 10.0 * gExplodeDistortion);\n    uv += explode * uv;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (gSceneId != SCENE_MANDEL) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv = distortion(uv);\n\n    Camera camera;\n    camera.eye = vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ);\n    camera.target = vec3(gCameraTargetX, gCameraTargetY, gCameraTargetZ);\n    camera.up = vec3(0.0, 1.0, 0.0);  // y-up\n    Ray ray = cameraShootRay(camera, uv);\n\n    vec3 color = vec3(0.0);\n    vec3 reflection = vec3(1.0);\n    Intersection intersection;\n\n    for (int bounce = 0; bounce < 2; bounce++) {\n        calcRadiance(intersection, ray);\n        color += reflection * intersection.color;\n        if (!intersection.hit || intersection.reflectance == 0.0) break;\n        reflection *= intersection.reflectance;\n\n        bool isIncoming = dot(ray.direction, intersection.normal) < 0.0;\n        vec3 orientingNormal = isIncoming ? intersection.normal : -intersection.normal;\n\n        bool isTotalReflection = false;\n        if (intersection.transparent) {\n            float nnt = isIncoming ? 1.0 / intersection.refractiveIndex : intersection.refractiveIndex;\n            ray.origin = intersection.position - orientingNormal * OFFSET;\n            ray.direction = refract(ray.direction, orientingNormal, nnt);\n            isTotalReflection = (ray.direction == vec3(0.0));\n            bounce = 0;\n        }\n\n        if (isTotalReflection || !intersection.transparent) {\n            ray.origin = intersection.position + orientingNormal * OFFSET;\n            vec3 l = reflect(ray.direction, orientingNormal);\n            reflection *= fresnelSchlick(gF0, dot(l, orientingNormal));\n            ray.direction = l;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="// #define STRIP_FIXED\n\nuniform float gSceneId;   // 0 0 2 scene\nuniform float gSceneEps;  // 0.002 0.00001 0.01\n#define SCENE_MANDEL 0.0\n#define SCENE_UNIVERSE 1.0\n\nuniform float gCameraEyeX;     // 0 -100 100 camera\nuniform float gCameraEyeY;     // 2.8 -100 100\nuniform float gCameraEyeZ;     // -8 -100 100\nuniform float gCameraTargetX;  // 0 -100 100\nuniform float gCameraTargetY;  // 2.75 -100 100\nuniform float gCameraTargetZ;  // 0 -100 100\nuniform float gCameraFov;      // 13 0 180\n\n// consts\nconst float INF = 1e+10;\nconst float OFFSET = 0.1;\n\n// ray\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// camera\nstruct Camera {\n    vec3 eye, target;\n    vec3 forward, right, up;\n};\n\nRay cameraShootRay(Camera c, vec2 uv) {\n    c.forward = normalize(c.target - c.eye);\n    c.right = normalize(cross(c.forward, c.up));\n    c.up = normalize(cross(c.right, c.forward));\n\n    Ray r;\n    r.origin = c.eye;\n    r.direction = normalize(uv.x * c.right + uv.y * c.up + c.forward / tan(gCameraFov / 360.0 * PI));\n\n    return r;\n}\n\n// intersection\nstruct Intersection {\n    bool hit;\n    vec3 position;\n    float distance;\n    vec3 normal;\n    vec2 uv;\n    float count;\n\n    vec3 baseColor;\n    float roughness;\n    float reflectance;\n    float metallic;\n    vec3 emission;\n\n    bool transparent;\n    float refractiveIndex;\n\n    vec3 color;\n};\n\n// util\n#define calcNormal(p, dFunc, eps)                                                                                                                                                 \\\n    normalize(vec2(eps, -eps).xyy *dFunc(p + vec2(eps, -eps).xyy) + vec2(eps, -eps).yyx * dFunc(p + vec2(eps, -eps).yyx) + vec2(eps, -eps).yxy * dFunc(p + vec2(eps, -eps).yxy) + \\\n              vec2(eps, -eps).xxx * dFunc(p + vec2(eps, -eps).xxx))\n\n// Distance Functions\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\n\nfloat sdCircle(vec2 p, float r) { return length(p) - r; }\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nmat2 rotate(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 uvSphere(vec3 n) {\n    float u = 0.5 + atan(n.z, n.x) / TAU;\n    float v = 0.5 - asin(n.y) / PI;\n    return vec2(u, v);\n}\n\nuniform float gPlanetsId;  // 0 0 4 planets\n#define PLANETS_MERCURY 0.0\n#define PLANETS_MIX_A 1.0\n#define PLANETS_KANETA 2.0\n#define PLANETS_FMSCAT 3.0\n#define PLANETS_MIX_B 4.0\n#define PLANETS_EARTH 5.0\n\n#define PLANETS_PAT_MAX 6\n#define PLANETS_NUM_MAX 6\n\nvec3[PLANETS_PAT_MAX * PLANETS_NUM_MAX] planetCenters = vec3[](\n    // MERCURY\n    vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0),\n    // MIX_A\n    vec3(-10.0, 1.0, 3.0), vec3(-6.0, -1.0, 2.0), vec3(0.0, 0.0, 0.0), vec3(6.0, 0.0, 8.0), vec3(8.0, 3.0, 2.0), vec3(0.0),\n    // KANETA\n    vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0),\n    // PLANETS_FMSCAT\n    vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0),\n    // MIX_B\n    vec3(-7.0, 1.0, 3.0), vec3(-3.0, -3.5, 2.0), vec3(0.0, 0.0, 0.0), vec3(6.0, 0.0, 8.0), vec3(6.0, -3.0, 2.0), vec3(6.0, 5.0, -3.0),\n    // EARTH\n    vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n\n// fbmAmp, fbmFreq, fbmYScale, fbmShift\nvec4[PLANETS_PAT_MAX * PLANETS_NUM_MAX] planetFbmParams = vec4[](\n    // MERCURY\n    vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0),\n    // MIX_A\n    vec4(0.05, 10.0, 1.05, 0.0), vec4(0.3, 17.0, 1.0, 0.01), vec4(0.05, 10.0, 1.05, 0.01), vec4(0.05, 10.0, 4.05, 0.02), vec4(0.05, 10.0, 2.05, 00.1), vec4(0.0),\n    // KANETA\n    vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0),\n    // PLANETS_FMSCAT\n    vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0),\n    // MIX_B\n    vec4(0.0, 10.0, 1.0, 0.2), vec4(0.0, 10.0, 1.0, 0.01), vec4(0.0, 10.0, 1.0, 0.03), vec4(0.05, 10.0, 1.0, 00.2), vec4(0.06, 10.0, 1.0, 0.03), vec4(0.05, 10.0, 1.0, 0.03),\n    // EARTH\n    vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));\n\nint[PLANETS_PAT_MAX] planetNums = int[](1, 5, 1, 1, 6, 1);\nfloat[PLANETS_PAT_MAX] planetTextIds = float[](7.0, 8.0, 13.0, 14.0, 15.0, 0.0);\n\nfloat voronoi(in vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float rid = -1.;\n    vec2 r = vec2(2.);\n    for (int i = -1; i <= 0; i++)\n        for (int j = -1; j <= 0; j++)\n            for (int k = -1; k <= 0; k++) {\n                vec3 g = vec3(i, j, k);\n                // float h = hash(ip - g);\n                vec3 pp = fp + g + hash33(ip - g) * .6;\n                float d = dot(pp, pp);\n\n                if (d < r.x) {\n                    r.y = r.x;\n                    r.x = d;\n                    // rid = h +.5;\n                } else if (d < r.y) {\n                    r.y = d;\n                }\n            }\n    return r.x;\n}\n\n// https://www.shadertoy.com/view/llSGRw\nfloat craters(vec3 p) {\n    float v = voronoi(p);\n    return sin(sqrt(v) * TAU) * exp(-4. * v);\n}\n\nfloat hMercury(vec3 p) {\n    p.xz = rotate(beat * 0.05) * p.xz;\n    float f = 1.2;\n\n    float r = 0.0;\n    for (int i = 0; i < 5; i++) {\n        r += abs(craters(p * f)) / f;\n        f *= 2.7;\n    }\n    return r;\n}\n\nfloat dMercury(vec3 p) {\n    float d = sdSphere(p, 1.0);\n\n    if (d < 1.0) {\n        d += 0.075 * hMercury(p);\n    }\n\n    return d;\n}\n\nfloat hPlanetsMix(vec2 p, int id) {\n    p.y *= planetFbmParams[id].z;\n    return fbm(p + planetFbmParams[id].w * fbm(p, 4.0 * planetFbmParams[id].y), planetFbmParams[id].y);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) { return a + b * cos(TAU * (c * t + d)); }\n\nfloat dPlanetsMix(vec3 p) {\n    float d = INF;\n\n    for (int i = 0; i < planetNums[int(gPlanetsId)]; i++) {\n        int id = PLANETS_NUM_MAX * int(gPlanetsId) + i;\n        vec3 center = planetCenters[id];\n        vec3 q = p - center;\n        float s = sdSphere(q, 1.0);\n        if (s < 1.0) {\n            vec2 uv = uvSphere(normalize(q));\n            s -= planetFbmParams[id].x * hPlanetsMix(uv, id);\n        }\n        d = min(d, s);\n    }\n\n    return d;\n}\n\nvec2 opU(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nvec2 opS(vec2 d1, vec2 d2) { return (-d1.x > d2.x) ? vec2(-d1.x, d1.y) : d2; }\n\nvec2 opSU(vec2 d1, vec2 d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2.x - d1.x) / k, 0.0, 1.0);\n    return vec2(mix(d2.x, d1.x, h) - k * h * (1.0 - h), d1.y);\n}\n\nmat2 rot(float th) {\n    vec2 a = sin(vec2(1.5707963, 0) + th);\n    return mat2(a, -a.y, a.x);\n}\n\n#define MAT_BODY 1.0\n#define MAT_FACE 2.0\n#define MAT_HAND 3.0\n#define MAT_BROW 4.0\n\n// https://www.shadertoy.com/view/wslSRr\nvec2 thinkingFace(vec3 p) {\n    vec2 face = vec2(sdSphere(p, 1.0), MAT_BODY);\n\n    vec3 q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.3);\n    q.yz *= rot(-0.25 + 0.05 * step(0.0, p.x));\n    q.y *= 0.8;\n    q.z *= 2.0;\n    q.z -= 2.0;\n    vec2 eye = vec2(sdSphere(q, .11) * 0.5, MAT_FACE);\n\n    q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.35);\n    q.yz *= rot(-0.62 + 0.26 * step(0.0, p.x) + pow(abs(q.x), 1.7) * 0.5);\n    q.z -= 1.0;\n    vec2 brow = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .05) * 0.5, MAT_BROW);\n\n    q = p;\n    q.yz *= rot(0.2 + pow(abs(p.x), 1.8));\n    q.xy *= rot(-0.25);\n    q.z -= 1.0;\n    vec2 mouth = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .045), MAT_BROW);\n\n    p -= vec3(-.25, -.73, 1.0);\n    p.xy *= rot(0.2);\n    q = p;\n    q = (q * vec3(1.2, 1.0, 2.0));\n    q -= vec3(0.0, 0.01, 0.0);\n    vec2 hand = vec2(sdSphere(q, .3) * 0.5, MAT_HAND);\n\n    q = p;\n\n    vec2 finger1 = vec2(sdCapsule(q - vec3(0.3, 0.2, 0.02), vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .07), MAT_HAND);\n    vec2 finger2 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.2, 0.06, 0.02), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger3 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.15, -0.08, 0.015), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger4 = vec2(sdCapsule(q * vec3(1.2, 1.0, .9) - vec3(0.1, -0.2, -0.01), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n\n    p -= vec3(-0.1, 0.3, 0.0);\n    q = p;\n    q.x -= q.y * 0.7;\n\n    vec2 finger5 = vec2(sdCapsule(p, vec3(0.0, -0.2, 0.0) - q, vec3(0.0, 0.2, 0.0), .1 - p.y * 0.15), MAT_HAND);\n    vec2 finger = opU(finger1, opU(finger5, opSU(finger2, opSU(finger3, finger4, 0.035), 0.035)));\n\n    hand = opSU(hand, finger, 0.02);\n\n    vec2 d = opU(eye, face);\n    d = opU(brow, d);\n    d = opS(mouth, d);\n    d = opU(hand, d);\n    return d;\n}\n\nvoid transformKaneta(inout vec3 p) { p.xz = rotate(remapTo(easeInOutCubic(remapFrom(beat, 212.0, 216.0)), -1.7, 0.7)) * p.xz; }\n\nfloat hKaneta(vec3 p) {\n    vec2 uv = uvSphere(normalize(p));\n    return fbm(uv, 20.0);\n}\n\nfloat dKaneta(vec3 p) {\n    transformKaneta(p);\n\n#ifdef STRIP_FIXED\n    float d = sdSphere(p, 1.0);  // thinkingFace のコンパイルに時間がかかるのでSphereで代用\n#else\n    float d = thinkingFace(p).x;\n#endif\n\n    if (d < 1.0) {\n        d -= 0.02 * hKaneta(p);\n    }\n\n    return d;\n}\n\nfloat sminCubic(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\nfloat hFmsCat(vec3 p) {\n    vec2 uv = uvSphere(normalize(p));\n    vec2 grid = vec2(100.0, 50.0) * sin(remap(beat, 216.0, 220.0, 0.5, PI - 0.01));\n    uv = floor(uv * grid) / grid;\n    return fbm(uv, 5.0);\n}\n\nfloat dFmsCat(vec3 p) {\n    float d = sdSphere(p, 1.0);\n    float k = 0.3;\n    vec3 size = vec3(remap(p.y, -0.5, 1.5, 0.3, 0.5), 0.3 + 0.3 * abs(p.x), remap(p.y, 0.0, 1.3, 0.1, 0.0));\n    d = sminCubic(d, sdBox(p - vec3(-0.5, 0.5, 0.0), size), k);\n    d = sminCubic(d, sdBox(p - vec3(0.5, 0.5, 0.0), size), k);\n\n    if (d < 1.0) {\n        d -= 0.05 * hFmsCat(p);\n    }\n\n    return d;\n}\n\nvoid transformEarth(inout vec3 p) { p.xz = rotate(0.1 * beat) * p.xz; }\n\nfloat hEarth(vec3 p, out vec2 uv) {\n    uv = uvSphere(normalize(p));\n    return fbm(uv, 10.0);\n}\n\nfloat dEarth(vec3 p) {\n    transformEarth(p);\n    float d = sdSphere(p, 1.0);\n\n    if (d < 1.0) {\n        vec2 uv;\n        d -= 0.05 * hEarth(p, uv);\n    }\n\n    return d;\n}\n\nfloat dPlanets(vec3 p) {\n    float d = INF;\n\n    if (gPlanetsId == PLANETS_MERCURY) {\n        d = min(d, dMercury(p));\n    } else if (gPlanetsId == PLANETS_MIX_A || gPlanetsId == PLANETS_MIX_B) {\n        d = min(d, dPlanetsMix(p));\n    } else if (gPlanetsId == PLANETS_KANETA) {\n        d = min(d, dKaneta(p));\n    } else if (gPlanetsId == PLANETS_FMSCAT) {\n        d = min(d, dFmsCat(p));\n    } else if (gPlanetsId == PLANETS_EARTH) {\n        d = min(d, dEarth(p));\n    }\n\n    return d;\n}\n\nfloat dGomi(vec3 p) {\n    float d = 1.0;\n\n    vec3 g = vec3(floor(p / 4.0));\n    p = mod(p, 4.0) - 2.0;\n\n    vec3 rand = hash33(g);\n    float rate = (gPlanetsId != PLANETS_EARTH) ? 0.08 : 0.01;\n    if (rand.x < rate) {\n        p -= (rand - 0.5);\n        d = sdSphere(p, 0.1 * rand.y);\n    }\n\n    if (d < 0.5) {\n        vec2 uv = uvSphere(normalize(p));\n        uv.x += dot(rand, vec3(1.0));\n        d -= remapTo(rand.z, 0.01, 0.08) * fbm(uv, 5.0);\n    }\n\n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = dPlanets(p);\n    d = min(d, dGomi(p));\n    return d;\n}\n\nfloat logicoma(vec2 uv) {\n    float d = sdCircle(uv - vec2(0.0, -0.5), 0.05);\n    d = min(d, sdCircle(uv - vec2(-0.5, 0.5), 0.05));\n    d = min(d, sdCircle(uv - vec2(0.5, 0.5), 0.05));\n    return d < 0.0 ? 1.0 : 0.0;\n}\n\nfloat dMenger(vec3 z0, vec3 offset, float scale) {\n    vec4 z = vec4(z0, 1.0);\n    for (int n = 0; n < 3; n++) {\n        z = abs(z);\n\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n\n        if (z.z < -0.5 * offset.z * (scale - 1.0)) {\n            z.z += offset.z * (scale - 1.0);\n        }\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0)) - 0.05) / z.w;\n}\n\nuniform vec3 gPlanetPalA;       // 127 127 127\nuniform vec3 gPlanetPalB;       // 110 115 115\nuniform vec3 gPlanetPalC;       // 256 178 102\nuniform float gPlanetPalScale;  // 1.2332 1.1 1.3\n\nuniform float gYosshinX;   // 2.071136418317427 0 5\nuniform float gYosshinY;   // 1.1 0 5\nuniform float gYosshinZ;   // 0.8 0 5\nuniform float gYosshinS;   // 2.6 0 5\nuniform float gYosshinS2;  // 0.5050689006252655 0 5\n\nfloat yosshin(vec3 p) {\n    p /= gYosshinS2;\n    float d = dMenger(p, vec3(gYosshinX, gYosshinY, gYosshinZ), gYosshinS);\n    return d < 0.0 ? 1.0 : 0.0;\n}\n\nfloat prismbeings(vec2 uv) {\n    int i = int(uv.y * 16.0);\n    int j = int(uv.x + beat);\n    return float((i >> (int(beat * 4.0) % 8) & j) & 1);\n}\n\nuniform float gF0;                    // 0.95 0 1 lighting\nuniform float gCameraLightIntensity;  // 1 0 10\n\nfloat fresnelSchlick(float f0, float cosTheta) { return f0 + (1.0 - f0) * pow((1.0 - cosTheta), 5.0); }\n\nvoid intersectObjects(inout Intersection intersection, inout Ray ray) {\n    float d;\n    float distance = 0.0;\n    vec3 p = ray.origin;\n    float eps = 0.02;\n\n    for (float i = 0.0; i < 200.0; i++) {\n        d = map(p);\n        distance += d;\n        p = ray.origin + distance * ray.direction;\n        intersection.count = i;\n        if (d < eps) break;\n    }\n\n    if (d < eps) {\n        intersection.distance = distance;\n        intersection.hit = true;\n        intersection.position = p;\n        intersection.normal = calcNormal(p, map, gSceneEps);\n\n        intersection.transparent = false;\n        intersection.refractiveIndex = 1.2;\n        intersection.reflectance = 0.0;\n\n        if (dPlanets(p) < eps) {\n            if (gPlanetsId == PLANETS_MERCURY) {\n                intersection.baseColor = vec3(0.7);\n                intersection.roughness = 0.4;\n                intersection.metallic = 0.01;\n                intersection.emission = vec3(0.0);\n            } else if (gPlanetsId == PLANETS_MIX_A || gPlanetsId == PLANETS_MIX_B) {\n                int id;\n                vec2 uv;\n                vec3 dir;\n                vec3 offset;\n\n                for (int i = 0; i < planetNums[int(gPlanetsId)]; i++) {\n                    vec3 center = planetCenters[PLANETS_NUM_MAX * int(gPlanetsId) + i];\n                    offset = p - center;\n                    float d = sdSphere(offset, 1.0);\n                    if (abs(d) < eps * 100.0) {\n                        id = PLANETS_NUM_MAX * int(gPlanetsId) + i;\n                        dir = normalize(offset);\n                        uv = uvSphere(dir);\n                        break;\n                    }\n                }\n\n                float seed = float(id);\n                float h = hPlanetsMix(uv, id);\n                vec3 rand = hash31(seed * gPlanetPalScale);\n                intersection.baseColor = pal(h, gPlanetPalA, gPlanetPalB, gPlanetPalC, rand);\n                intersection.roughness = 0.4;\n                intersection.metallic = 0.8 * rand.x;\n                intersection.emission = vec3(0.0);\n\n                if (id == int(PLANETS_MIX_A) * PLANETS_NUM_MAX + 1) {\n                    // intersection.baseColor = mix(vec3(1.0), vec3(0.5), remapFrom(h, 0.7, 0.95));\n                }\n\n                if (id == int(PLANETS_MIX_B) * PLANETS_NUM_MAX) {\n                    intersection.baseColor = vec3(0.05);\n                    intersection.emission = vec3(0.0);\n                    intersection.metallic = 0.9;\n                    intersection.reflectance = 0.9;\n                    intersection.roughness = 0.01;\n                }\n\n                if (id == int(PLANETS_MIX_B) * PLANETS_NUM_MAX + 1) {\n                    intersection.baseColor = vec3(0.0);\n                    intersection.emission = vec3(0.3, 0.3, 0.5) * prismbeings(dir.xy);\n                    intersection.metallic = 0.9;\n                    intersection.reflectance = 0.9;\n                    intersection.roughness = 0.01;\n                }\n\n                if (id == int(PLANETS_MIX_B) * PLANETS_NUM_MAX + 4) {\n                    intersection.emission = vec3(0.5, 0.5, 0.8) * logicoma(dir.xy);\n                }\n\n                if (id == int(PLANETS_MIX_B) * PLANETS_NUM_MAX + 2) {\n                    intersection.baseColor = vec3(0.1);\n                    intersection.emission = vec3(0.3, 0.3, 0.5) * yosshin(offset);\n                    intersection.metallic = 0.5;\n                }\n            } else if (gPlanetsId == PLANETS_KANETA) {\n                transformKaneta(p);\n                float h = hKaneta(p);\n                intersection.baseColor = mix(vec3(0.8, 0.5, 0.2), vec3(0.9, 0.95, 0.5), h);\n                intersection.roughness = 0.4;\n                intersection.metallic = 0.01;\n                intersection.emission = vec3(0.0);\n            } else if (gPlanetsId == PLANETS_FMSCAT) {\n                float h = hFmsCat(p);\n                intersection.baseColor = pal(sin(h * remap(beat, 216.0, 220.0, 1.0, 5.0) + 0.25 * beat * TAU), vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.33, 0.67));\n                intersection.roughness = 0.4;\n                intersection.metallic = 0.01;\n                intersection.emission = 0.2 * intersection.baseColor;\n            } else if (gPlanetsId == PLANETS_EARTH) {\n                transformEarth(p);\n                vec2 uv;\n                float h = hEarth(p, uv);\n\n                if (h > 0.67) {\n                    // land\n                    intersection.baseColor = mix(vec3(0.03, 0.21, 0.14), vec3(240., 204., 170.) / 255., remapFrom(h, 0.72, 0.99));\n                    intersection.roughness = 0.4;\n                    intersection.metallic = 0.01;\n                    intersection.emission = vec3(0.0);\n                    intersection.emission = vec3(0.07, 0.1, 0.07) * remapFrom(h, 0.67, 0.8);\n                } else {\n                    // sea\n                    intersection.baseColor = mix(vec3(0.01, 0.03, 0.05), vec3(3.0, 18.0, 200.0) / 255.0, remapFrom(h, 0.0, 0.6));\n                    intersection.roughness = 0.1;\n                    intersection.metallic = 0.134;\n                    intersection.emission = vec3(0.1, 0.3, 1.0) * remapFrom(h, 0.1, 0.67);\n                }\n\n                intersection.emission *= fresnelSchlick(0.15, saturate(dot(-ray.direction, intersection.normal)));\n\n                float cloud = fbm(uv, 15.0);\n                intersection.baseColor = mix(intersection.baseColor, vec3(1.5), pow(cloud, 4.0));\n            }\n        } else {\n            // gomi\n            intersection.baseColor = vec3(0.7);\n            intersection.roughness = 0.4;\n            intersection.metallic = 0.01;\n            intersection.emission = vec3(0.0);\n        }\n    }\n}\n\n// http://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms\nbool intersectAABB(inout Intersection intersection, inout Ray ray, vec3 lb, vec3 rt) {\n    vec3 dirfrac;\n    dirfrac.x = 1.0 / ray.direction.x;\n    dirfrac.y = 1.0 / ray.direction.y;\n    dirfrac.z = 1.0 / ray.direction.z;\n\n    float t1 = (lb.x - ray.origin.x) * dirfrac.x;\n    float t2 = (rt.x - ray.origin.x) * dirfrac.x;\n    float t3 = (lb.y - ray.origin.y) * dirfrac.y;\n    float t4 = (rt.y - ray.origin.y) * dirfrac.y;\n    float t5 = (lb.z - ray.origin.z) * dirfrac.z;\n    float t6 = (rt.z - ray.origin.z) * dirfrac.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmin <= tmax && 0.0 <= tmin && tmin < intersection.distance) {\n        intersection.hit = true;\n        intersection.position = ray.origin + ray.direction * (tmin > 0.0 ? tmin : tmax);\n        intersection.distance = tmin;\n\n        vec3 uvw = (intersection.position - lb) / (rt - lb);\n        intersection.normal = vec3(0.0, 0.0, 1.0);\n        intersection.uv = uvw.xy;\n        return true;\n    }\n\n    return false;\n}\n\nvoid intersectScene(inout Intersection intersection, inout Ray ray) {\n    intersection.distance = INF;\n    intersectObjects(intersection, ray);\n\n    if (beat < 224.0) {\n        Intersection textIntersection = intersection;\n\n        for (int i = 0; i < planetNums[int(gPlanetsId)]; i++) {\n            vec3 center = planetCenters[PLANETS_NUM_MAX * int(gPlanetsId) + i];\n            if (intersectAABB(textIntersection, ray, center + vec3(-2.0, 1.5, 0.0), center + vec3(2.0, 2.5, 0.01))) {\n                vec2 uv = (2.0 * textIntersection.uv - 1.0) * vec2(1.0, 0.25);\n                float id = planetTextIds[int(gPlanetsId)] + float(i);\n                vec3 t = texture(iTextTexture, textUv(uv, id, vec2(0.0, 0.0), 2.0)).rgb;\n                // alpha test\n                if (length(t) > 0.01) {\n                    intersection.emission = 0.5 * t;\n                    intersection.hit = true;\n                    break;\n                }\n            }\n        }\n    }\n}\n\n#define FLT_EPS 5.960464478e-8\n\nfloat roughnessToExponent(float roughness) { return clamp(2.0 * (1.0 / (roughness * roughness)) - 2.0, FLT_EPS, 1.0 / FLT_EPS); }\n\nvec3 evalPointLight(inout Intersection i, vec3 v, vec3 lp, vec3 radiance) {\n    vec3 n = i.normal;\n    vec3 p = i.position;\n    vec3 ref = mix(vec3(0.04), i.baseColor, i.metallic);\n\n    vec3 l = lp - p;\n    float len = length(l);\n    l /= len;\n\n    vec3 h = normalize(l + v);\n\n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), i.metallic) * i.baseColor / PI;\n    float m = roughnessToExponent(i.roughness);\n    vec3 specular = ref * pow(max(0.0, dot(n, h)), m) * (m + 2.0) / (8.0 * PI);\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n)) / (len * len);\n}\n\nvec3 evalDirectionalLight(inout Intersection i, vec3 v, vec3 lightDir, vec3 radiance) {\n    vec3 n = i.normal;\n    vec3 p = i.position;\n    vec3 ref = mix(vec3(0.04), i.baseColor, i.metallic);\n\n    vec3 l = lightDir;\n    vec3 h = normalize(l + v);\n\n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), i.metallic) * i.baseColor / PI;\n    float m = roughnessToExponent(i.roughness);\n    vec3 specular = ref * pow(max(0.0, dot(n, h)), m) * (m + 2.0) / (8.0 * PI);\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n));\n}\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat fractal(vec3 p, int n) {\n    float strength = 7.0;\n    float accum = 0.25;\n    float prev = 0.;\n    float tw = 0.;\n    for (int i = 0; i < n; i++) {\n        float mag = dot(p, p);\n        p = abs(p) / mag + vec3(-.5, -.4, -1.5);\n        float w = exp(-float(i) / 7.);\n        accum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n        tw += w;\n        prev = mag;\n    }\n    return max(0., 5. * accum / tw - .7);\n}\n\nvec3 skyboxUniverse(vec2 uv) {\n    // stars\n    vec3 col = vec3(1.2) * pow(fbm(uv * 200.0), 10.0);\n\n    float b = saturate(cos(TAU * beat / 8.0));\n\n    float f = fractal(vec3(0.2 * uv + vec2(0.3, 0.1), 1.7 + (beat - 192.0) * 0.001), 28);\n    col = mix(col, 0.3 * vec3(1.3 * f * f * f * b, 1.8 * f * f, f), f);\n\n    f = fractal(vec3(0.2 * uv + vec2(0.8, 0.2), 2.7 + (beat - 192.0) * 0.002), 15);\n    col = mix(col, 0.05 * vec3(1.9 * f * f * f, 1.3 * f * f, 1.3 * f * f), f * 0.5);\n\n    return col;\n}\n\nvoid calcRadiance(inout Intersection intersection, inout Ray ray) {\n    intersection.hit = false;\n    intersectScene(intersection, ray);\n\n    if (intersection.hit) {\n        intersection.color = intersection.emission;\n        intersection.color += evalPointLight(intersection, -ray.direction, vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ), gCameraLightIntensity * vec3(80.0, 80.0, 100.0));\n        // intersection.color += evalPointLight(intersection, -ray.direction, vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ + 4.0), vec3(0.0));\n\n        vec3 sunColor = vec3(1.0, 0.9, 0.8);\n        intersection.color += evalDirectionalLight(intersection, -ray.direction, vec3(-0.48666426339228763, 0.8111071056538127, 0.3244428422615251), sunColor);\n\n        // fog\n        // intersection.color = mix(intersection.color, vec3(0.6),\n        //                         1.0 - exp(-0.0001 * intersection.distance *\n        //                         intersection.distance *\n        //                         intersection.distance));\n    } else {\n        intersection.color = vec3(0.01);\n\n        if (gSceneId == SCENE_UNIVERSE) {\n            float rdo = ray.direction.y + 0.6;\n            vec2 uv = (ray.direction.xz + ray.direction.xz * 250000.0 / rdo) * 0.000008;\n            intersection.color += skyboxUniverse(uv);\n        }\n    }\n}\n\nuniform float gShockDistortion;    // 0 0 1 distortion\nuniform float gExplodeDistortion;  // 0 0 1\n\nvec2 distortion(vec2 uv) {\n    float l = length(uv);\n    // uv += 1.5 * uv * sin(l + beat * PIH);\n\n    uv += -gShockDistortion * uv * cos(l);\n\n    float explode = 30.0 * gExplodeDistortion * exp(-2.0 * l);\n    explode = mix(explode, 2.0 * sin(l + 10.0 * gExplodeDistortion), 10.0 * gExplodeDistortion);\n    uv += explode * uv;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (gSceneId != SCENE_UNIVERSE) {\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor = texture(iPrevPass, uv);\n        return;\n    }\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv = distortion(uv);\n\n    Camera camera;\n    camera.eye = vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ);\n    camera.target = vec3(gCameraTargetX, gCameraTargetY, gCameraTargetZ);\n    camera.up = vec3(0.0, 1.0, 0.0);  // y-up\n    Ray ray = cameraShootRay(camera, uv);\n\n    vec3 color = vec3(0.0);\n    vec3 reflection = vec3(1.0);\n    Intersection intersection;\n\n    for (int bounce = 0; bounce < 2; bounce++) {\n        calcRadiance(intersection, ray);\n        color += reflection * intersection.color;\n        if (!intersection.hit || intersection.reflectance == 0.0) break;\n        reflection *= intersection.reflectance;\n\n        bool isIncoming = dot(ray.direction, intersection.normal) < 0.0;\n        vec3 orientingNormal = isIncoming ? intersection.normal : -intersection.normal;\n\n        bool isTotalReflection = false;\n        if (intersection.transparent) {\n            float nnt = isIncoming ? 1.0 / intersection.refractiveIndex : intersection.refractiveIndex;\n            ray.origin = intersection.position - orientingNormal * OFFSET;\n            ray.direction = refract(ray.direction, orientingNormal, nnt);\n            isTotalReflection = (ray.direction == vec3(0.0));\n            bounce = 0;\n        }\n\n        if (isTotalReflection || !intersection.transparent) {\n            ray.origin = intersection.position + orientingNormal * OFFSET;\n            vec3 l = reflect(ray.direction, orientingNormal);\n            reflection *= fresnelSchlick(gF0, dot(l, orientingNormal));\n            ray.direction = l;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="void text(vec2 uv, inout vec3 result) {\r\n    vec3 col = vec3(0.0);\r\n    float b = beat - 224.0;\r\n    float t4 = mod(b, 4.0) / 4.0;\r\n    float t8 = mod(b, 8.0) / 8.0;\r\n    float brightness = 1.0;\r\n\r\n    if (b < 0.0) {\r\n        // nop\r\n    } else if (b < 4.0) {\r\n        // 0-4 (4)\r\n        // A 64k INTRO\r\n        col += texture(iTextTexture, textUv(uv, 0.0, vec2(0.0, 0.0), 3.0)).rgb;\r\n        col *= remap(t4, 0.5, 1.0, 1.0, 0.0);\r\n    } else if (b < 8.0) {\r\n        // 4-8 (4)\r\n        // gam0022 & sadakkey\r\n        col += texture(iTextTexture, textUv(uv, 1.0, vec2(-1.0, 0.1), 1.0)).rgb;\r\n        col += texture(iTextTexture, textUv(uv, 2.0, vec2(-1.0, -0.1), 1.0)).rgb;\r\n\r\n        col += texture(iTextTexture, textUv(uv, 3.0, vec2(1.0, 0.1), 1.0)).rgb;\r\n        col += texture(iTextTexture, textUv(uv, 4.0, vec2(1.0, -0.1), 1.0)).rgb;\r\n        col *= remap(t4, 0.5, 1.0, 1.0, 0.0);\r\n    } else if (b < 16.0) {\r\n        // 8-16 (8)\r\n        // RE: SIMULATED\r\n        col += texture(iTextTexture, textUv(uv, 5.0, vec2(0.0, 0.0), 3.0)).rgb;\r\n        col *= remap(t8, 0.5, 1.0, 0.0, 1.0);\r\n    } else if (b < 20.0) {\r\n        // 16-20 (4)\r\n        // RE: SIMULATED -> RE\r\n        float t = remapFrom(t4, 0.75, 1.0);\r\n        // t = easeInOutCubic(t);\r\n        // t = pow(t4, 1.4);\r\n\r\n        vec2 glitch = vec2(0.0);\r\n        float fade = uv.x - remapTo(t, 1.6, -0.78);\r\n        if (fade > 0.0) {\r\n            glitch = hash23(vec3(floor(vec2(uv.x * 32.0, uv.y * 8.0)), beat));\r\n            glitch.x = fade * fade * remapTo(glitch.x, 0.0 * t, 0.05 * t);\r\n            glitch.y = fade * fade * remapTo(glitch.y, -0.4 * t, 0.3 * t);\r\n            fade = saturate(1.0 - fade) * saturate(1.0 - abs(glitch.y));\r\n        } else {\r\n            fade = 1.0;\r\n        }\r\n\r\n        float a = saturate(cos(fract(b * TAU * 4.0)));\r\n        col.r += fade * texture(iTextTexture, textUv(uv + glitch * mix(0.5, 1.0, a), 5.0, vec2(0.0, 0.0), 3.0)).r;\r\n        col.g += fade * texture(iTextTexture, textUv(uv + glitch * mix(1.5, 1.0, a), 5.0, vec2(0.0, 0.0), 3.0)).g;\r\n        col.b += fade * texture(iTextTexture, textUv(uv + glitch * mix(2.0, 1.0, a), 5.0, vec2(0.0, 0.0), 3.0)).b;\r\n    } else if (b < 24.0) {\r\n        // 20-24 (4)\r\n        // RE\r\n        col += texture(iTextTexture, textUv(uv, 6.0, vec2(-0.553, 0.0), 3.0)).rgb;\r\n        if (uv.x > -0.78) {\r\n            col *= 0.0;\r\n        }\r\n        brightness = remapTo(t4, 1.0, 0.5);\r\n    } else {\r\n        // 24-32 (8)\r\n        // REALITY\r\n        col += texture(iTextTexture, textUv(uv, 6.0, vec2(-0.553, 0.0), 3.0)).rgb;\r\n        float t = remapFrom(t8, 0.75, 0.85);\r\n        // t = easeInOutCubic(t);\r\n        t = pow(t, 4.0);\r\n        if (uv.x > remapTo(t, -0.78, 1.0)) {\r\n            col *= 0.0;\r\n        }\r\n        col *= remap(t8, 0.75, 1.0, 1.0, 0.0);\r\n        brightness = remapTo(t8, 0.5, 0.0);\r\n    }\r\n\r\n    result *= brightness;\r\n    result += 0.3 * col;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    vec3 col = texture(iPrevPass, uv).rgb;\r\n\r\n    uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\r\n    text(uv, col);\r\n    fragColor = vec4(col, 1.0);\r\n}"},function(n,e,t){"use strict";t.r(e),e.default="uniform float gChromaticAberrationIntensity;  // 0.03 0 0.1 post\nuniform float gChromaticAberrationDistance;   // 0.45 0 1\n\nuniform float gVignetteIntensity;   // 1.34 0 3\nuniform float gVignetteSmoothness;  // 2 0 5\nuniform float gVignetteRoundness;   // 1 0 1\n\nuniform float gTonemapExposure;  // 0.1 0.0 2\nuniform float gBlend;            // 0 -1 1\n\nuniform float gGlitchIntensity;  // 0 0 0.1\nuniform float gInvertRate;       // 0 0 1\n\nvec3 chromaticAberration(vec2 uv) {\n    vec2 d = abs(uv - 0.5);\n    float f = mix(0.5, dot(d, d), gChromaticAberrationDistance);\n    f *= f * gChromaticAberrationIntensity;\n    vec2 shift = vec2(f);\n\n    float a = 2.0 * hash11(beat) - 1.0;\n    vec2 grid = hash23(vec3(floor(vec2(uv.x * (4.0 + 8.0 * a), (uv.y + a) * 32.0)), beat));\n    grid = 2.0 * grid - 1.0;\n    shift += exp(-5.0 * fract(beat)) * gGlitchIntensity * grid;\n\n    vec3 col;\n    col.r = texture(iPrevPass, uv + shift).r;\n    col.g = texture(iPrevPass, uv).g;\n    col.b = texture(iPrevPass, uv - shift).b;\n    return col;\n}\n\nfloat vignette(vec2 uv) {\n    vec2 d = abs(uv - 0.5) * gVignetteIntensity;\n    float roundness = (1.0 - gVignetteRoundness) * 6.0 + gVignetteRoundness;\n    d = pow(d, vec2(roundness));\n    return pow(saturate(1.0 - dot(d, d)), gVignetteSmoothness);\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 invert(vec3 c, vec2 uv) {\n    if (hash12(vec2(floor(uv.y * gInvertRate * 32.0), beat)) < gInvertRate) {\n        return vec3(1.0) - c;\n    } else {\n        return c;\n    }\n}\n\nvec3 blend(vec3 c) {\n    c = mix(c, vec3(1.0), saturate(gBlend));\n    c = mix(c, vec3(0.0), saturate(-gBlend));\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = chromaticAberration(uv);\n    col *= vignette(uv);\n    col = acesFilm(col * gTonemapExposure);\n    col = pow(col, vec3(1.0 / 2.2));\n    col = invert(col, uv);\n    col = blend(col);\n    fragColor = vec4(col, 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="float brightness(vec3 c) { return max(max(c.r, c.g), c.b); }\n\nuniform float gBloomThreshold;  // 1.0 0 100 bloom\nuniform float gBloomSoftKnee;   // 0.5 0 4\n\n// https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Runtime/Components/BloomComponent.cs#L65-L67\n// https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Resources/Shaders/Bloom.shader#L86-L117\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float softKnee = gBloomSoftKnee;\n    float lthresh = gBloomThreshold;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iPrevPass, uv);\n    vec3 m = color.rgb;\n    float br = brightness(m);\n\n    float knee = lthresh * softKnee + 1e-5;\n    vec3 curve = vec3(lthresh - knee, knee * 2.0, 0.25 / knee);\n    float rq = clamp(br - curve.x, 0.0, curve.y);\n    rq = curve.z * rq * rq;\n\n    m *= max(rq, br - lthresh) / max(br, 1e-5);\n    m = max(m, vec3(0.0));\n\n    fragColor = vec4(m, color.a);\n}"},function(n,e,t){"use strict";t.r(e),e.default="void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    fragColor = vec4(tap4(iPrevPass, uv, texelSize), 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="uniform sampler2D iBeforeBloom;\nuniform sampler2D iPairBloomDown;\n\nuniform float gBloomSpread;  // 1.3 1 2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec3 col = texture(iPairBloomDown, uv).rgb;\n    fragColor = vec4(col + gBloomSpread * tap4(iPrevPass, uv, texelSize), 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="uniform sampler2D iBeforeBloom;\nuniform sampler2D iPairBloomDown;\n\nuniform float gBloomIntensity;  // 1 0 30\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec3 col = texture(iBeforeBloom, uv).rgb;\n    vec3 pair = texture(iPairBloomDown, uv).rgb;\n    fragColor = vec4(col + gBloomIntensity * tap4(iPrevPass, uv, texelSize), 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="#version 300 es\nprecision mediump float;\nuniform float iSampleRate;\nuniform float iBlockOffset;\n\nvec2 mainSound(float time);\n\nout vec4 outColor;\nvoid main() {\n    float t = iBlockOffset + ((gl_FragCoord.x - 0.5) + (gl_FragCoord.y - 0.5) * 512.0) / iSampleRate;\n    vec2 y = mainSound(t);\n    vec2 v = floor((0.5 + 0.5 * y) * 65536.0);\n    vec2 vl = mod(v, 256.0) / 255.0;\n    vec2 vh = floor(v / 256.0) / 255.0;\n    outColor = vec4(vl.x, vh.x, vl.y, vh.y);\n}\n\n//--------------------\n// ここから下を書き換える\n//--------------------\n#define BPM 140.0\n#define PI 3.141592654\n#define TAU 6.283185307\n\nfloat sidechain;\nfloat sidechain2;\nfloat sidechain3;\nfloat sidechain4;\nfloat sidechain5;\n\n// general functions\nfloat timeToBeat(float t) { return t / 60.0 * BPM; }\nfloat beatToTime(float b) { return b / BPM * 60.0; }\nfloat noteToFreq(float n) { return 440.0 * pow(2.0, (n - 69.0) / 12.0); }\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 noise(float p) {\n    vec4 p4 = fract(vec4(p) * vec4(.1050, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy + 55.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n// quantize https://www.shadertoy.com/view/ldfSW2\nfloat quan(float s, float c) { return floor(s / c) * c; }\n\n// hash\nfloat nse(float x) {\n    return fract(sin(x * 110.082) * 19871.8972);\n    // return fract(sin(x * 110.082) * 13485.8372);\n}\n\nfloat dist(float s, float d) { return clamp(s * d, -1.0, 1.0); }\n\n// primitive oscillators\nfloat sine(float phase) { return sin(TAU * phase); }\nfloat saw(float phase) { return 2.0 * fract(phase) - 1.0; }\nfloat square(float phase) { return fract(phase) < 0.5 ? -1.0 : 1.0; }\nfloat tri(float phase) { return abs(2. * fract(phase * .5 - .25) - 1.) * 2. - 1.; }\n\n// drums\nfloat kick(float note, float time) {\n    float amp = exp(-2.0 * time);\n    float phase = 33.0 * time - 16.0 * exp(-60.0 * time);\n    return amp * sine(phase);\n}\n\nvec2 hihat(float note, float time) {\n    float amp = exp(-50.0 * time);\n    return amp * noise(time * 100.0).xy;\n}\n\nvec2 hihat2(float note, float time) {\n    float amp = exp(-70.0 * time);\n    return amp * noise(time * 300.0).xy;\n}\n\nvec2 hihat3(float note, float time) {\n    float amp = exp(-50.0 * time);\n    float phase = 200.0 * time - 300.0 * exp(-40.0 * time);\n    return amp * noise(time * 300.0).xy;\n}\n\n// https://www.shadertoy.com/view/ldfSW2\nvec2 crash1(float note, float time) {\n    {\n        // tb = fract(tb / 4.0) * 0.5;\n        float aa = 15.0;\n        time = sqrt(time * aa) / aa;\n        float amp = exp(max(time - 0.15, 0.0) * -5.0);\n        float v = nse(quan(mod(time, 0.6), 0.0001));\n        v = dist(v, 0.1) * amp;\n        return vec2(dist(v * amp, 2.0));\n    }\n}\n\n// synths\nvec2 bass(float note, float time) {\n    float freq = noteToFreq(note);\n    return vec2(saw(freq * time) + sine(freq * time)) / 1.5;\n}\n\nvec2 subbass(float note, float time) {\n    float freq = noteToFreq(note);\n    return vec2(sine(freq * time)) / 2.0;\n}\n\nvec2 arp(float note, float time) {\n    float freq = noteToFreq(note);\n    float fmamp = 0.1 * exp(-30.0 * time);\n    float fm = fmamp * square(time * freq * 1.5);\n    float amp = exp(-50.0 * time);\n    return amp * vec2(square(freq * time), tri(freq * time));\n}\n\nvec2 arpsaw(float note, float time) {\n    float freq = noteToFreq(note);\n    float fmamp = 0.02 * exp(-30.0 * time);\n    float fm = fmamp * sine(time * freq * 1.0);\n    float amp = exp(-20.0 * time);\n    return amp * vec2(sine(freq * 0.999 * time + fm), saw(freq * 1.001 * time + fm));\n}\n\nvec2 arpsine(float note, float time) {\n    float freq = noteToFreq(note);\n    float fmamp = 0.02 * exp(-70.0 * time);\n    float fm = fmamp * sine(time * freq * 1.0);\n    float amp = exp(-50.0 * time);\n    return amp * vec2(sine(freq * 0.999 * time + fm), sine(freq * 1.001 * time + fm));\n}\n\nvec2 arpsine2(float note, float time) {\n    float freq = noteToFreq(note);\n    float fmamp = 0.02 * exp(-30.0 * time);\n    float fm = fmamp * sine(time * freq * 1.0);\n    float amp = exp(-30.0 * time);\n    return amp * vec2(sine(freq * 0.999 * time + fm), sine(freq * 1.001 * time + fm));\n}\n\nvec2 supersaw(float note, float time) {\n    float amp = exp(0.0 * time * time);\n    float vib = 0.2 * sine(3.0 * time);\n    float ret = 0.0;\n    int num = 3;\n    float step = 0.014;\n    int reverbNum = 100;\n\n    for (int i = 0; i < num; i++) {\n        float freq = noteToFreq(note + 12.0 * float(i - num / 2));\n        for (int j = 0; j < reverbNum; j++) {\n            ret += saw(freq * (time - 0.008 * float(j)) * (1.0 + step * float(i - num / 2))) * exp(-3.0 * float(j));\n        }\n    }\n\n    return vec2(0.5 * amp * ret / float(num));\n}\n\nvec2 basssaw1(float note, float time) {\n    float amp = exp(15.0 * time * time);\n    float ret = 0.0;\n    int num = 2;\n    float step = 0.014;\n    int reverbNum = 100;\n\n    for (int i = 0; i < num; i++) {\n        float freq = noteToFreq(note + 12.0 * float(i - num / 2));\n        for (int j = 0; j < reverbNum; j++) {\n            ret += saw(freq * (time - 0.008 * float(j)) * (1.0 + step * float(i - num / 2))) * exp(-3.0 * float(j));\n        }\n    }\n\n    return vec2(0.5 * amp * ret / float(num));\n}\n\nvec2 basssaw2(float note, float time) {\n    float amp = exp(15.0 * time * time);\n    float ret = 0.0;\n    int num = 2;\n    float step = 0.014;\n    int reverbNum = 100;\n\n    for (int i = 0; i < num; i++) {\n        float freq = noteToFreq(note + 12.0 * float(i - num / 2));\n        for (int j = 0; j < reverbNum; j++) {\n            ret += saw(freq * (time - 0.008 * float(j)) * (1.0 + step * float(i - num / 2))) * exp(-3.0 * float(j));\n        }\n    }\n\n    return vec2(0.5 * amp * ret / float(num));\n}\n\nvec2 basssaw3(float note, float time) {\n    float amp = exp(1.3 * time * time);\n    float ret = 0.0;\n    int num = 3;\n    float step = 0.014;\n    int reverbNum = 100;\n\n    for (int i = 0; i < num; i++) {\n        float freq = noteToFreq(note + 12.0 * float(i - num / 2));\n        for (int j = 0; j < reverbNum; j++) {\n            ret += saw(freq * (time - 0.008 * float(j)) * (1.0 + step * float(i - num / 2))) * exp(-3.0 * float(j));\n        }\n    }\n\n    return vec2(0.5 * amp * ret / float(num));\n}\n\nvec2 chordsaw1(float note, float time) {\n    float amp = exp(0.0 * time * time);\n    float env = exp(time * 3.0);\n    float ret = 0.0;\n    int num = 3;\n    float step = 0.023;\n    int reverbNum = 100;\n\n    for (int i = 0; i < num; i++) {\n        float freq = noteToFreq(note + 12.0 * float(i - num / 2));\n        for (int j = 0; j < reverbNum; j++) {\n            ret += saw(freq * (time - 0.019 * float(j)) * (1.0 + step * float(i - num / 2))) * exp(-3.0 * float(j));\n        }\n    }\n\n    return vec2(0.4 * amp * ret / float(num));\n}\n\nvec2 chordsaw2(float note, float time) {\n    float amp = exp(0.0 * time * time);\n    float env = exp(time * 3.0);\n    float ret = 0.0;\n    int num = 3;\n    float step = 0.0225;\n    int reverbNum = 100;\n\n    for (int i = 0; i < num; i++) {\n        float freq = noteToFreq(note + 12.0 * float(i - num / 2));\n        for (int j = 0; j < reverbNum; j++) {\n            ret += saw(freq * (time + 0.019 * float(j)) * (1.0 + step * float(i - num / 2))) * exp(-2.0 * float(j));\n        }\n    }\n\n    return vec2(0.4 * env * amp * ret / float(num));\n}\n\nvec2 chordsquare1(float note, float time) {\n    float amp = exp(-15.0 * time * time);\n    float ret = 0.0;\n    int num = 3;\n    float step = 0.023;\n    int reverbNum = 100;\n\n    for (int i = 0; i < num; i++) {\n        float freq = noteToFreq(note + 12.0 * float(i - num / 2));\n        for (int j = 0; j < reverbNum; j++) {\n            ret += saw(freq * (time + 0.019 * float(j)) * (1.0 + step * float(i - num / 2))) * exp(-3.0 * float(j));\n        }\n    }\n\n    return vec2(0.5 * amp * ret / float(num));\n}\n\n#define NSPC 256\n\n// hard clipping distortion\n// float dist(float s, float d) { return clamp(s * d, -1.0, 1.0); }\nvec2 dist(vec2 s, float d) { return clamp(s * d, -1.0, 1.0); }\n\n// my resonant lowpass filter's frequency response\nfloat _filter(float h, float cut) {\n    cut -= 20.0;\n    float df = max(h - cut, 0.0), df2 = abs(h - cut);\n    return exp(-0.005 * df * df) * 0.5 + exp(df2 * df2 * -0.1) * 2.2;\n}\n\n// tb303 core\nvec2 synth(float note, float t) {\n    vec2 v = vec2(0.0);\n    float dr = 0.15;\n    float amp = smoothstep(0.1, 0.0, abs(t - dr - 0.1) - dr) * exp(t * 0.2);\n    float f = noteToFreq(note);\n    float sqr = 0.1;  // smoothstep(0.0, 0.01, abs(mod(t * 9.0, 64.0) - 20.0) - 20.0);\n\n    float base = f;                    // 50.0 + sin(sin(t * 0.1) * t) * 20.0;\n    float flt = exp(t * -1.5) * 30.0;  // + pow(cos(t * 1.0) * 0.5 + 0.5, 4.0) * 80.0 - 0.0;\n    for (int i = 0; i < NSPC; i++) {\n        float h = float(i + 1);\n        float inten = 2.0 / h;\n        // inten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * pi2) * 0.9 + 0.1;\n\n        inten = mix(inten, inten * mod(h, 2.0), sqr);\n\n        inten *= exp(-2.0 * max(2.0 - h, 0.0));  // + exp(abs(h - flt) * -2.0) * 8.0;\n\n        inten *= _filter(h, flt);\n\n        v.x += inten * sin((TAU + 0.01) * (t * base * h));\n        v.y += inten * sin(TAU * (t * base * h));\n    }\n\n    float o = v.x * amp;  // exp(max(tnote - 0.3, 0.0) * -5.0);\n\n    // o = dist(o, 2.5);\n\n    return vec2(dist(v * amp, 2.0));\n}\n\nvec2 synth1_echo(float note, float time) {\n    vec2 v;\n    v = synth(note, time) * 0.5;  // + synth2(time) * 0.5;\n    float ec = 0.4, fb = 0.3, et = 2.0 / 9.0, tm = 2.0 / 9.0;\n    v += synth(note, time - et) * ec * vec2(1.0, 0.5);\n    ec *= fb;\n    et += tm;\n    v += synth(note, time - et).yx * ec * vec2(0.5, 1.0);\n    ec *= fb;\n    et += tm;\n    v += synth(note, time - et) * ec * vec2(1.0, 0.5);\n    ec *= fb;\n    et += tm;\n    v += synth(note, time - et).yx * ec * vec2(0.5, 1.0);\n    ec *= fb;\n    et += tm;\n\n    return v;\n}\n\nvec2 attackbass(float note, float t) {\n    vec2 v = vec2(0.0);\n    float dr = 0.15;\n    float amp = smoothstep(0.1, 0.0, abs(t - dr - 0.1) - dr) * exp(t * 0.2);\n    float f = noteToFreq(note);\n    float sqr = 0.1;  // smoothstep(0.0, 0.01, abs(mod(t * 9.0, 64.0) - 20.0) - 20.0);\n\n    float base = f;                    // 50.0 + sin(sin(t * 0.1) * t) * 20.0;\n    float flt = exp(t * -1.5) * 30.0;  // + pow(cos(t * 1.0) * 0.5 + 0.5, 4.0) * 80.0 - 0.0;\n    for (int i = 0; i < NSPC; i++) {\n        float h = float(i + 1);\n        float inten = 2.0 / h;\n        // inten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * pi2) * 0.9 + 0.1;\n\n        inten = mix(inten, inten * mod(h, 2.0), sqr);\n\n        inten *= exp(-2.0 * max(2.0 - h, 0.0));  // + exp(abs(h - flt) * -2.0) * 8.0;\n\n        inten *= _filter(h, flt);\n\n        v.x += inten * sin((TAU + 0.01) * (t * base * h));\n        v.y += inten * sin(TAU * (t * base * h));\n    }\n\n    float o = v.x * amp;  // exp(max(tnote - 0.3, 0.0) * -5.0);\n\n    // o = dist(o, 2.5);\n\n    return vec2(dist(v * amp, 2.0));\n}\n\nvec2 leadsub(float note, float t) {\n    vec2 v = vec2(0.0);\n    float dr = 0.1;\n    float amp = smoothstep(0.2, 0.0, abs(t - dr - 0.1) - dr) * exp(t * 0.2);\n    float f = noteToFreq(note);\n    float sqr = 0.03;  // smoothstep(0.0, 0.01, abs(mod(t * 9.0, 64.0) - 20.0) - 20.0);\n\n    float base = f;                    // 50.0 + sin(sin(t * 0.1) * t) * 20.0;\n    float flt = exp(t * -3.5) * 20.0;  // + pow(cos(t * 1.0) * 0.5 + 0.5, 4.0) * 80.0 - 0.0;\n    for (int i = 0; i < NSPC; i++) {\n        float h = float(i + 1);\n        float inten = 2.0 / h;\n        // inten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * pi2) * 0.9 + 0.1;\n\n        inten = mix(inten, inten * mod(h, 2.0), sqr);\n\n        inten *= exp(-2.0 * max(2.0 - h, 0.0));  // + exp(abs(h - flt) * -2.0) * 8.0;\n\n        inten *= _filter(h, flt);\n\n        v.x += inten * sin((TAU + 0.01) * (t * base * h));\n        v.y += inten * sin(TAU * (t * base * h));\n    }\n\n    float o = v.x * amp;  // exp(max(tnote - 0.3, 0.0) * -5.0);\n\n    // o = dist(o, 2.5);\n\n    return vec2(dist(v * amp, 2.0));\n}\n\n// https://www.shadertoy.com/view/4sSSWz\nfloat noise2(float phi) { return fract(sin(phi * 0.055753) * 122.3762) * 4.0 - 3.0; }\n\nvec2 snare(float note, float t) {\n    float i = t * iSampleRate;\n    float env = exp(-t * 17.0);  // 全音符で使うなら 10.0 じゃなくて 3.0 くらいの方がいいかも\n    float v = 0.3 * env * (2.3 * noise2(i) + 0.5 * sin(30.0 * i));\n    return vec2(v);\n}\n\nvec2 snarefill(float note, float t) {\n    float i = t * iSampleRate;\n    float env = exp(-t * 30.0);  // 全音符で使うなら 10.0 じゃなくて 3.0 くらいの方がいいかも\n    float v = 0.2 * env * (2.3 * noise2(i) + 0.5 * sin(30.0 * i));\n    return vec2(v);\n}\n\nvec2 noisefeedin(float note, float t) {\n    float i = t * iSampleRate;\n    float env = exp(-t * 1.0);  // 全音符で使うなら 10.0 じゃなくて 3.0 くらいの方がいいかも\n    float v = 0.05 * env * (3.3 * noise2(i) + 0.5 * sin(30.0 * i));\n    return vec2(v);\n}\n\nvec2 sidechainnoise(float note, float t) {\n    float i = t * iSampleRate;\n    float env = exp(-t * 3.0);  // 全音符で使うなら 10.0 じゃなくて 3.0 くらいの方がいいかも\n    float v = 0.03 * env * (3.3 * noise2(i) + 0.3 * sin(20.0 * i));\n    return vec2(v);\n}\n\nvec2 sidechainnoise2(float note, float t) {\n    float i = t * iSampleRate;\n    float env = exp(-t * 3.0);  // 全音符で使うなら 10.0 じゃなくて 3.0 くらいの方がいいかも\n    float v = 0.1 * env * (3.3 * noise2(i) + 0.3 * sin(20.0 * i));\n    return vec2(v);\n}\n\n// 1ビートを最大何分割するか。16分音符に対応するなら4\n#define NOTE_VDIV 4\n\n// 1ビートのpackingを考慮した分割数。32bitのintに16bitずつ詰めているので 4 / (32 / 16) = 2\n#define NOTE_DIV 2\n\n// 展開用の配列のpacking数。32bitのintに4bitずつ詰めているので 32 / 4 = 8\n#define DEV_PACK 8\n\n#define MAX_BEAT_LEN 8\nint[MAX_BEAT_LEN * NOTE_VDIV] tmpIndexes;\n\n#define O(a)                                                                                                                                                                                 \\\n    (a | 1 << 8) | ((a | 1 << 8) << 16), (a | 1 << 8) | ((a | 1 << 8) << 16), (a | 1 << 8) | ((a | 1 << 8) << 16), (a | 1 << 8) | ((a | 1 << 8) << 16), (a | 1 << 8) | ((a | 1 << 8) << 16), \\\n        (a | 1 << 8) | ((a | 1 << 8) << 16), (a | 1 << 8) | ((a | 1 << 8) << 16), (a | 1 << 8) | ((a | 1 << 8) << 16)\n#define F(a) (a | 4 << 8) | ((a | 4 << 8) << 16), (a | 4 << 8) | ((a | 4 << 8) << 16)\n#define E2(a, b) (a | 8 << 8) | ((a | 8 << 8) << 16), (b | 8 << 8) | ((b | 8 << 8) << 16)\n#define S4(a, b, c, d) (a | 16 << 8) | ((b | 16 << 8) << 16), (c | 16 << 8) | ((d | 16 << 8) << 16)\n#define D8(a, b, c, d, e, f, g, h) (a) | (b << 4) | (c << 8) | (d << 12) | (e << 16) | (f << 20) | (g << 24) | (h << 28)\n\n#define SEQUENCER(beat, time, beatLen, devPat, devLen, notes, development, toneFunc)                     \\\n    int indexOffset = development[int(mod(beat / float(beatLen * DEV_PACK), float(devLen / DEV_PACK)))]; \\\n    indexOffset = (indexOffset >> (4 * int(mod(beat / float(beatLen), float(DEV_PACK))))) & 15;          \\\n    indexOffset *= beatLen * NOTE_VDIV;                                                                  \\\n                                                                                                         \\\n    for (int i = 0; i < beatLen * NOTE_VDIV;) {                                                          \\\n        int index = i + indexOffset;                                                                     \\\n        int shift = (index % 2 == 1) ? 16 : 0;                                                           \\\n        int div = ((notes[index >> 1] >> shift) >> 8) & 255;                                             \\\n        int len = NOTE_VDIV * NOTE_VDIV / div;                                                           \\\n        for (int j = 0; j < len; j++) {                                                                  \\\n            tmpIndexes[i + j] = i;                                                                       \\\n        }                                                                                                \\\n        i += len;                                                                                        \\\n    }                                                                                                    \\\n                                                                                                         \\\n    float indexFloat = mod(beat * float(NOTE_VDIV), float(beatLen * NOTE_VDIV));                         \\\n    int index = int(indexFloat);                                                                         \\\n    int shift = (index % 2 == 1) ? 16 : 0;                                                               \\\n    int note = (notes[(index + indexOffset) >> 1] >> shift) & 255;                                       \\\n    float localTime = beatToTime((indexFloat - float(tmpIndexes[index])) / float(NOTE_VDIV));            \\\n    float amp = (note == 0) ? 0.0 : 1.0;                                                                 \\\n    vec2 ret = vec2(toneFunc(float(note), localTime) * amp);\n\n//  KICK  //\n\nvec2 kick1(float beat, float time) {\n// 1つの展開のビート数\n#define KICK1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define KICK1_DEV_PAT 3\n\n// 展開の長さ\n#define KICK1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[KICK1_BEAT_LEN * NOTE_DIV * KICK1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        F(1),\n\n        // 2\n        F(0),\n\n        // 3\n        F(0),\n\n        // 4\n        E2(0, 1),\n\n        // 5\n        F(1),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(1),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(1),\n\n        // 2\n        F(1),\n\n        // 3\n        F(1),\n\n        // 4\n        F(1),\n\n        // 5\n        F(1),\n\n        // 6\n        F(1),\n\n        // 7\n        F(1),\n\n        // 8\n        F(1),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        F(1),\n\n        // 2\n        F(1),\n\n        // 3\n        F(1),\n\n        // 4\n        F(1),\n\n        // 5\n        F(1),\n\n        // 6\n        F(1),\n\n        // 7\n        F(1),\n\n        // 8\n        F(0));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[KICK1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 2, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1));\n\n    SEQUENCER(beat, time, KICK1_BEAT_LEN, KICK1_DEV_PAT, KICK1_DEV_LEN, notes, development, kick)\n\n    if (beat < 128.0) {\n        sidechain = smoothstep(-0.2, 0.6, localTime);\n    } else {\n        sidechain = smoothstep(-0.1, 0.6, localTime);\n    }\n\n    if (beat < 64.0) {\n        sidechain2 = smoothstep(-0.1, 0.7, localTime);\n    } else {\n        sidechain2 = smoothstep(-0.2, 0.7, localTime);\n    }\n\n    if (beat < 64.0) {\n        sidechain3 = smoothstep(-0.0, 0.9, localTime);\n    } else {\n        sidechain3 = smoothstep(-0.2, 0.7, localTime);\n    }\n\n    sidechain4 = smoothstep(-0.4, 0.6, localTime);\n    sidechain5 = smoothstep(0.0, 0.2, localTime);\n\n    return ret;\n}\n\nvec2 crashcymbal1(float beat, float time) {\n// 1つの展開のビート数\n#define CRASH1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define CRASH1_DEV_PAT 3\n\n// 展開の長さ\n#define CRASH1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[CRASH1_BEAT_LEN * NOTE_DIV * CRASH1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(1),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開2（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(1),\n\n        // 2\n        F(0),\n\n        // 3\n        F(0),\n\n        // 4\n        F(0),\n\n        // 5\n        F(1),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(0));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[CRASH1_DEV_LEN / DEV_PACK] development = int[](D8(0, 1, 1, 1, 0, 1, 2, 2), D8(0, 1, 1, 1, 0, 1, 2, 2), D8(0, 1, 1, 1, 0, 1, 1, 1), D8(0, 1, 1, 1, 0, 1, 1, 1));\n\n    SEQUENCER(beat, time, CRASH1_BEAT_LEN, CRASH1_DEV_PAT, CRASH1_DEV_LEN, notes, development, crash1)\n\n    return ret;\n}\n\nvec2 crashcymbal2(float beat, float time) {\n// 1つの展開のビート数\n#define CRASH1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define CRASH1_DEV_PAT 3\n\n// 展開の長さ\n#define CRASH1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[CRASH1_BEAT_LEN * NOTE_DIV * CRASH1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(1),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開2（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(0),\n\n        // 3\n        F(1),\n\n        // 4\n        F(0),\n\n        // 5\n        F(0),\n\n        // 6\n        F(0),\n\n        // 7\n        F(1),\n\n        // 8\n        F(0));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[CRASH1_DEV_LEN / DEV_PACK] development = int[](D8(1, 1, 0, 1, 1, 0, 2, 2), D8(1, 1, 1, 1, 1, 0, 2, 2), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1));\n\n    SEQUENCER(beat, time, CRASH1_BEAT_LEN, CRASH1_DEV_PAT, CRASH1_DEV_LEN, notes, development, crash1)\n\n    return ret;\n}\n\n//   BASS   //\n\nvec2 bass1(float beat, float time) {\n// 1つの展開のビート数\n#define BASS1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define BASS1_DEV_PAT 11\n\n// 展開の長さ\n#define BASS1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[BASS1_BEAT_LEN * NOTE_DIV * BASS1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(33),\n\n        // 3\n        E2(0, 33),\n\n        // 4\n        S4(0, 33, 0, 33),\n\n        // 5\n        F(0),\n\n        // 6\n        F(33),\n\n        // 7\n        E2(0, 33),\n\n        // 8\n        S4(0, 33, 0, 33),\n\n        //\n        // 展開1\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(33),\n\n        // 3\n        E2(0, 33),\n\n        // 4\n        S4(0, 33, 0, 33),\n\n        // 5\n        F(0),\n\n        // 6\n        F(33),\n\n        // 7\n        E2(0, 33),\n\n        // 8\n        S4(0, 33, 0, 33),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 33, 33, 33),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(29, 29),\n\n        // 6\n        S4(0, 29, 29, 29),\n\n        // 7\n        S4(0, 31, 31, 31),\n\n        // 8\n        S4(48, 47, 43, 40),\n\n        //\n        // 展開4\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 34, 34, 34),\n\n        //\n        // 展開5\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 36, 36, 36),\n\n        //\n        // 展開6\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 34, 34, 34),\n\n        // 8\n        S4(0, 36, 36, 36),\n\n        //\n        // 展開7\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 43, 43, 43),\n\n        // 8\n        S4(0, 55, 57, 69),\n\n        //\n        // 展開8\n        //\n\n        // 1\n        E2(29, 29),\n\n        // 2\n        S4(0, 29, 29, 29),\n\n        // 3\n        S4(0, 29, 29, 29),\n\n        // 4\n        S4(0, 31, 33, 45),\n\n        // 5\n        E2(29, 29),\n\n        // 6\n        S4(0, 29, 29, 29),\n\n        // 7\n        S4(0, 29, 29, 29),\n\n        // 8\n        S4(0, 31, 31, 31),\n\n        //\n        // 展開9\n        //\n\n        // 1\n        E2(26, 26),\n\n        // 2\n        S4(0, 26, 26, 26),\n\n        // 3\n        S4(0, 26, 26, 26),\n\n        // 4\n        S4(0, 26, 28, 26),\n\n        // 5\n        E2(28, 28),\n\n        // 6\n        S4(0, 28, 28, 28),\n\n        // 7\n        S4(0, 28, 28, 28),\n\n        // 8\n        S4(0, 43, 45, 57),\n\n        //\n        // 展開10\n        //\n\n        // 1\n        E2(29, 29),\n\n        // 2\n        S4(0, 29, 29, 29),\n\n        // 3\n        S4(0, 29, 29, 29),\n\n        // 4\n        S4(0, 31, 33, 45),\n\n        // 5\n        E2(29, 29),\n\n        // 6\n        S4(0, 29, 29, 29),\n\n        // 7\n        S4(0, 31, 31, 31),\n\n        // 8\n        S4(0, 31, 31, 31));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[BASS1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(2, 2, 2, 3, 4, 5, 6, 7), D8(8, 1, 8, 9, 8, 1, 10, 1), D8(1, 1, 1, 1, 1, 1, 1, 1));\n    SEQUENCER(beat, time, BASS1_BEAT_LEN, BASS1_DEV_PAT, BASS1_DEV_LEN, notes, development, bass)\n    return ret;\n}\n\nvec2 bass2(float beat, float time) {\n// 1つの展開のビート数 ベースのアタック\n#define BASS2_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define BASS2_DEV_PAT 11\n\n// 展開の長さ\n#define BASS2_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[BASS2_BEAT_LEN * NOTE_DIV * BASS2_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 33, 33, 33),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(41, 41),\n\n        // 6\n        S4(0, 41, 41, 41),\n\n        // 7\n        S4(0, 43, 43, 43),\n\n        // 8\n        F(0),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 33, 33, 33),\n\n        //\n        // 展開4\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 34, 34, 34),\n\n        //\n        // 展開5\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 36, 36, 36),\n\n        //\n        // 展開6\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 34, 34, 34),\n\n        // 8\n        S4(0, 36, 36, 36),\n\n        //\n        // 展開7\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 43, 43, 43),\n\n        // 8\n        S4(0, 55, 57, 69),\n\n        //\n        // 展開8\n        //\n\n        // 1\n        E2(29, 29),\n\n        // 2\n        S4(0, 29, 29, 29),\n\n        // 3\n        S4(0, 29, 29, 29),\n\n        // 4\n        S4(0, 31, 33, 45),\n\n        // 5\n        E2(29, 29),\n\n        // 6\n        S4(0, 29, 29, 29),\n\n        // 7\n        S4(0, 29, 29, 29),\n\n        // 8\n        S4(0, 31, 31, 31),\n\n        //\n        // 展開9\n        //\n\n        // 1\n        E2(26, 26),\n\n        // 2\n        S4(0, 26, 26, 26),\n\n        // 3\n        S4(0, 26, 26, 26),\n\n        // 4\n        S4(0, 26, 28, 26),\n\n        // 5\n        E2(28, 28),\n\n        // 6\n        S4(0, 28, 28, 28),\n\n        // 7\n        S4(0, 28, 28, 28),\n\n        // 8\n        S4(0, 43, 45, 57),\n\n        //\n        // 展開10\n        //\n\n        // 1\n        E2(29, 29),\n\n        // 2\n        S4(0, 29, 29, 29),\n\n        // 3\n        S4(0, 29, 29, 29),\n\n        // 4\n        S4(0, 31, 33, 45),\n\n        // 5\n        E2(29, 29),\n\n        // 6\n        S4(0, 29, 29, 29),\n\n        // 7\n        S4(0, 31, 31, 31),\n\n        // 8\n        S4(0, 31, 31, 31));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[BASS2_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 2, 4, 5, 6, 7), D8(8, 1, 8, 9, 8, 1, 10, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, BASS2_BEAT_LEN, BASS2_DEV_PAT, BASS2_DEV_LEN, notes, development, attackbass)\n    return ret;\n}\n\nvec2 bass3(float beat, float time) {\n    if (beat < 64.0) return vec2(0.0);\n    return basssaw3(33.0, beatToTime(mod(beat, 4.0)));\n}\n\nvec2 sideSupersaw1(float beat, float time) {\n// 1つの展開のビート数\n#define TAMESHI_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define TAMESHI_DEV_PAT 8\n\n// 展開の長さ\n#define TAMESHI_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[TAMESHI_BEAT_LEN * NOTE_DIV * TAMESHI_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        E2(45, 45),\n\n        // 2\n        S4(0, 45, 45, 45),\n\n        // 3\n        S4(0, 45, 45, 45),\n\n        // 4\n        S4(0, 45, 45, 45),\n\n        // 5\n        E2(45, 45),\n\n        // 6\n        S4(0, 45, 45, 45),\n\n        // 7\n        S4(0, 45, 45, 45),\n\n        // 8\n        S4(0, 45, 45, 45),\n\n        //\n        // 展開2（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        E2(45, 45),\n\n        // 2\n        S4(0, 45, 45, 45),\n\n        // 3\n        S4(0, 45, 45, 45),\n\n        // 4\n        S4(0, 45, 45, 45),\n\n        // 5\n        E2(41, 41),\n\n        // 6\n        S4(0, 41, 41, 41),\n\n        // 7\n        S4(0, 43, 43, 43),\n\n        // 8\n        F(0),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        E2(45, 45),\n\n        // 2\n        S4(0, 45, 45, 45),\n\n        // 3\n        S4(0, 45, 45, 45),\n\n        // 4\n        S4(0, 45, 45, 45),\n\n        // 5\n        E2(45, 45),\n\n        // 6\n        S4(0, 45, 45, 45),\n\n        // 7\n        S4(0, 45, 45, 45),\n\n        // 8\n        S4(0, 45, 45, 45),\n\n        //\n        // 展開4\n        //\n\n        // 1\n        E2(45, 45),\n\n        // 2\n        S4(0, 45, 45, 45),\n\n        // 3\n        S4(0, 45, 45, 45),\n\n        // 4\n        S4(0, 45, 45, 45),\n\n        // 5\n        E2(45, 45),\n\n        // 6\n        S4(0, 45, 45, 45),\n\n        // 7\n        S4(0, 45, 45, 45),\n\n        // 8\n        S4(0, 46, 46, 46),\n\n        //\n        // 展開5\n        //\n\n        // 1\n        E2(45, 45),\n\n        // 2\n        S4(0, 45, 45, 45),\n\n        // 3\n        S4(0, 45, 45, 45),\n\n        // 4\n        S4(0, 45, 45, 45),\n\n        // 5\n        E2(45, 45),\n\n        // 6\n        S4(0, 45, 45, 45),\n\n        // 7\n        S4(0, 45, 45, 45),\n\n        // 8\n        S4(0, 48, 48, 48),\n\n        //\n        // 展開6\n        //\n\n        // 1\n        E2(45, 45),\n\n        // 2\n        S4(0, 45, 45, 45),\n\n        // 3\n        S4(0, 45, 45, 45),\n\n        // 4\n        S4(0, 45, 45, 45),\n\n        // 5\n        E2(45, 45),\n\n        // 6\n        S4(0, 45, 45, 45),\n\n        // 7\n        S4(0, 46, 46, 46),\n\n        // 8\n        S4(0, 48, 48, 48),\n\n        //\n        // 展開7\n        //\n\n        // 1\n        E2(45, 45),\n\n        // 2\n        S4(0, 45, 45, 45),\n\n        // 3\n        S4(0, 45, 45, 45),\n\n        // 4\n        S4(0, 45, 45, 45),\n\n        // 5\n        E2(45, 45),\n\n        // 6\n        S4(0, 45, 45, 45),\n\n        // 7\n        S4(0, 55, 55, 55),\n\n        // 8\n        S4(0, 0, 0, 0));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[TAMESHI_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 2, 4, 5, 6, 7), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, TAMESHI_BEAT_LEN, TAMESHI_DEV_PAT, TAMESHI_DEV_LEN, notes, development, chordsaw1)\n    return ret;\n}\n\nvec2 sideSupersaw2(float beat, float time) {\n// 1つの展開のビート数\n#define TAMESHI_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define TAMESHI_DEV_PAT 8\n\n// 展開の長さ\n#define TAMESHI_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[TAMESHI_BEAT_LEN * NOTE_DIV * TAMESHI_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 33, 33, 33),\n\n        //\n        // 展開2（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(29, 29),\n\n        // 6\n        S4(0, 31, 31, 31),\n\n        // 7\n        S4(0, 31, 31, 31),\n\n        // 8\n        S4(0, 31, 31, 31),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 33, 33, 33),\n\n        //\n        // 展開4\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 34, 34, 34),\n\n        //\n        // 展開5\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 36, 36, 36),\n\n        //\n        // 展開6\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 34, 34, 34),\n\n        // 8\n        S4(0, 36, 36, 36),\n\n        //\n        // 展開7\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 43, 43, 43),\n\n        // 8\n        S4(0, 55, 57, 69));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[TAMESHI_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 2, 4, 5, 6, 7), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1));\n\n    SEQUENCER(beat, time, TAMESHI_BEAT_LEN, TAMESHI_DEV_PAT, TAMESHI_DEV_LEN, notes, development, chordsaw1)\n    return ret;\n}\n\nvec2 tb303synth(float beat, float time) {\n// 1つの展開のビート数\n#define TB303SYNTH1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define TB303SYNTH1_DEV_PAT 2\n\n// 展開の長さ\n#define TB303SYNTH1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[TB303SYNTH1_BEAT_LEN * NOTE_DIV * TB303SYNTH1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        F(33),\n\n        // 2\n        F(33),\n\n        // 3\n        F(33),\n\n        // 4\n        F(33),\n\n        // 5\n        F(33),\n\n        // 6\n        F(33),\n\n        // 7\n        F(33),\n\n        // 8\n        F(33),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        E2(33, 33),\n\n        // 2\n        S4(0, 33, 33, 33),\n\n        // 3\n        S4(0, 33, 33, 33),\n\n        // 4\n        S4(0, 33, 33, 33),\n\n        // 5\n        E2(33, 33),\n\n        // 6\n        S4(0, 33, 33, 33),\n\n        // 7\n        S4(0, 33, 33, 33),\n\n        // 8\n        S4(0, 33, 33, 33));\n\n    // 展開\n    int[TB303SYNTH1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, TB303SYNTH1_BEAT_LEN, TB303SYNTH1_DEV_PAT, TB303SYNTH1_DEV_LEN, notes, development, synth)\n    return ret;\n}\n\nvec2 arp0(float beat, float time) {\n    if (beat >= 64.0 && beat < 192.0) return vec2(0.0);\n\n// 1つの展開のビート数\n#define ARP0_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP0_DEV_PAT 1\n\n// 展開の長さ\n#define ARP0_DEV_LEN 8\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP0_BEAT_LEN * NOTE_DIV * ARP0_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(57, 57, 59, 59),\n\n        // 2\n        S4(60, 60, 64, 64),\n\n        // 3\n        S4(67, 67, 69, 69),\n\n        // 4\n        S4(71, 71, 74, 74),\n\n        // 5\n        S4(57, 57, 59, 59),\n\n        // 6\n        S4(60, 60, 64, 64),\n\n        // 7\n        S4(67, 67, 69, 69),\n\n        // 8\n        S4(71, 71, 74, 74));\n\n    // 展開\n    int[ARP0_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, ARP0_BEAT_LEN, ARP0_DEV_PAT, ARP0_DEV_LEN, notes, development, arpsaw)\n    return ret;\n}\n\nvec2 arp1(float beat, float time) {\n// 1つの展開のビート数\n#define ARP1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP1_DEV_PAT 2\n\n// 展開の長さ\n#define ARP1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP1_BEAT_LEN * NOTE_DIV * ARP1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(57, 0, 59, 0),\n\n        // 2\n        S4(60, 0, 64, 0),\n\n        // 3\n        S4(67, 0, 69, 0),\n\n        // 4\n        S4(71, 0, 74, 0),\n\n        // 5\n        S4(57, 0, 59, 0),\n\n        // 6\n        S4(60, 0, 64, 0),\n\n        // 7\n        S4(67, 0, 69, 0),\n\n        // 8\n        S4(71, 0, 74, 0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(57, 0, 59, 0),\n\n        // 2\n        S4(60, 0, 64, 0),\n\n        // 3\n        S4(67, 0, 69, 0),\n\n        // 4\n        S4(71, 0, 74, 0),\n\n        // 5\n        S4(57, 0, 59, 0),\n\n        // 6\n        S4(60, 0, 64, 0),\n\n        // 7\n        S4(67, 0, 69, 0),\n\n        // 8\n        S4(71, 0, 74, 0));\n\n    // 展開\n    int[ARP1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, ARP1_BEAT_LEN, ARP1_DEV_PAT, ARP1_DEV_LEN, notes, development, arp)\n    return ret;\n}\n\nvec2 arp2(float beat, float time) {\n// 1つの展開のビート数\n#define ARP2_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP2_DEV_PAT 2\n\n// 展開の長さ\n#define ARP2_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP2_BEAT_LEN * NOTE_DIV * ARP2_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(0, 57, 0, 59),\n\n        // 2\n        S4(0, 60, 0, 64),\n\n        // 3\n        S4(0, 67, 0, 69),\n\n        // 4\n        S4(0, 71, 0, 74),\n\n        // 5\n        S4(0, 69, 0, 71),\n\n        // 6\n        S4(0, 72, 0, 76),\n\n        // 7\n        S4(0, 79, 0, 81),\n\n        // 8\n        S4(0, 83, 0, 86),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(0, 69, 0, 71),\n\n        // 2\n        S4(0, 72, 0, 76),\n\n        // 3\n        S4(0, 79, 0, 81),\n\n        // 4\n        S4(0, 83, 0, 86),\n\n        // 5\n        S4(0, 69, 0, 71),\n\n        // 6\n        S4(0, 72, 0, 76),\n\n        // 7\n        S4(0, 79, 0, 81),\n\n        // 8\n        S4(0, 83, 0, 86));\n\n    // 展開\n    int[ARP2_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, ARP2_BEAT_LEN, ARP2_DEV_PAT, ARP2_DEV_LEN, notes, development, arp)\n    return ret;\n}\n\nvec2 arp3(float beat, float time) {\n// 1つの展開のビート数\n#define ARP3_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP3_DEV_PAT 2\n\n// 展開の長さ\n#define ARP3_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP3_BEAT_LEN * NOTE_DIV * ARP3_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(72, 60, 55, 64),\n\n        // 2\n        S4(0, 0, 0, 0),\n\n        // 3\n        S4(67, 55, 64, 55),\n\n        // 4\n        S4(0, 0, 0, 0),\n\n        // 5\n        S4(72, 60, 55, 64),\n\n        // 6\n        S4(0, 0, 0, 0),\n\n        // 7\n        S4(67, 55, 64, 55),\n\n        // 8\n        S4(0, 0, 0, 0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(72, 60, 55, 64),\n\n        // 2\n        S4(0, 0, 0, 0),\n\n        // 3\n        S4(67, 55, 64, 55),\n\n        // 4\n        S4(0, 0, 0, 0),\n\n        // 5\n        S4(72, 60, 55, 64),\n\n        // 6\n        S4(0, 0, 0, 0),\n\n        // 7\n        S4(67, 55, 64, 55),\n\n        // 8\n        S4(0, 0, 0, 0));\n\n    // 展開\n    int[ARP3_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, ARP3_BEAT_LEN, ARP3_DEV_PAT, ARP3_DEV_LEN, notes, development, arpsine)\n    return ret;\n}\n\nvec2 arp4(float beat, float time) {\n// 1つの展開のビート数\n#define ARP4_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP4_DEV_PAT 2\n\n// 展開の長さ\n#define ARP4_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP4_BEAT_LEN * NOTE_DIV * ARP4_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(0, 0, 0, 0),\n\n        // 2\n        S4(67, 60, 72, 55),\n\n        // 3\n        S4(0, 0, 0, 0),\n\n        // 4\n        S4(67, 60, 79, 62),\n\n        // 5\n        S4(0, 0, 0, 0),\n\n        // 6\n        S4(67, 60, 72, 55),\n\n        // 7\n        S4(0, 0, 0, 0),\n\n        // 8\n        S4(67, 60, 79, 62),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(0, 0, 0, 0),\n\n        // 2\n        S4(67, 60, 72, 55),\n\n        // 3\n        S4(0, 0, 0, 0),\n\n        // 4\n        S4(67, 60, 79, 62),\n\n        // 5\n        S4(0, 0, 0, 0),\n\n        // 6\n        S4(67, 60, 72, 55),\n\n        // 7\n        S4(0, 0, 0, 0),\n\n        // 8\n        S4(67, 60, 79, 62));\n\n    // 展開\n    int[ARP4_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, ARP4_BEAT_LEN, ARP4_DEV_PAT, ARP4_DEV_LEN, notes, development, arpsine)\n    return ret;\n}\n\nvec2 arp5(float beat, float time) {\n    if (beat < 64.0 || beat >= 192.0) return vec2(0.0);\n// 1つの展開のビート数\n#define ARP5_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP5_DEV_PAT 1\n\n// 展開の長さ\n#define ARP5_DEV_LEN 8\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP5_BEAT_LEN * NOTE_DIV * ARP5_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(69, 0, 79, 67),\n\n        // 2\n        S4(0, 0, 76, 0),\n\n        // 3\n        S4(0, 69, 0, 0),\n\n        // 4\n        S4(67, 0, 76, 0),\n\n        // 5\n        S4(69, 0, 79, 67),\n\n        // 6\n        S4(0, 0, 76, 0),\n\n        // 7\n        S4(0, 69, 0, 0),\n\n        // 8\n        S4(67, 0, 76, 0));\n\n    // 展開\n    int[ARP5_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, ARP5_BEAT_LEN, ARP5_DEV_PAT, ARP5_DEV_LEN, notes, development, arpsine2)\n    return ret;\n}\n\nvec2 hihat33(float beat, float time) {\n// 1つの展開のビート数\n#define HIHAT3_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define HIHAT3_DEV_PAT 3\n\n// 展開の長さ\n#define HIHAT3_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[HIHAT3_BEAT_LEN * NOTE_DIV * HIHAT3_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        F(1),\n\n        // 2\n        F(0),\n\n        // 3\n        F(0),\n\n        // 4\n        F(0),\n\n        // 5\n        F(0),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        E2(0, 1),\n\n        // 2\n        E2(0, 1),\n\n        // 3\n        E2(0, 1),\n\n        // 4\n        E2(0, 1),\n\n        // 5\n        E2(0, 1),\n\n        // 6\n        E2(0, 1),\n\n        // 7\n        E2(0, 1),\n\n        // 8\n        E2(0, 1),\n\n        //\n        // 展開2（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0));\n\n    // 展開 #define CRASH1_DEV_LEN 8　変える\n    int[HIHAT3_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(0, 0, 0, 0, 2, 2, 2, 2));\n\n    SEQUENCER(beat, time, HIHAT3_BEAT_LEN, HIHAT3_DEV_PAT, HIHAT3_DEV_LEN, notes, development, hihat3)\n\n    return ret;\n}\n\nvec2 subbass1(float beat, float time) {\n// 1つの展開のビート数\n#define SUB1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define SUB1_DEV_PAT 2\n\n// 展開の長さ\n#define SUB1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[SUB1_BEAT_LEN * NOTE_DIV * SUB1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        F(33),\n\n        // 2\n        F(33),\n\n        // 3\n        F(33),\n\n        // 4\n        F(33),\n\n        // 5\n        F(33),\n\n        // 6\n        F(33),\n\n        // 7\n        F(33),\n\n        // 8\n        F(33),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(33),\n\n        // 2\n        F(33),\n\n        // 3\n        F(33),\n\n        // 4\n        F(33),\n\n        // 5\n        F(33),\n\n        // 6\n        F(33),\n\n        // 7\n        F(33),\n\n        // 8\n        F(33));\n\n    // 展開 #define SUB1_DEV_LEN 8　変える\n    int[SUB1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1));\n\n    SEQUENCER(beat, time, SUB1_BEAT_LEN, SUB1_DEV_PAT, SUB1_DEV_LEN, notes, development, subbass)\n    return ret;\n}\n\n//  HIHAT  //\n//  HIHAT  //\n//  HIHAT  //\n\nvec2 testhihat2(float beat, float time) {\n// 1つの展開のビート数\n#define HIHAT2_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define HIHAT2_DEV_PAT 3\n\n// 展開の長さ\n#define HIHAT2_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[HIHAT2_BEAT_LEN * NOTE_DIV * HIHAT2_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(0, 1, 1, 1),\n\n        // 2\n        S4(0, 1, 1, 1),\n\n        // 3\n        S4(0, 1, 1, 1),\n\n        // 4\n        S4(0, 1, 1, 1),\n\n        // 5\n        S4(0, 1, 1, 1),\n\n        // 6\n        S4(0, 1, 1, 1),\n\n        // 7\n        S4(0, 1, 1, 1),\n\n        // 8\n        S4(0, 1, 1, 1),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(0, 1, 1, 1),\n\n        // 2\n        S4(0, 1, 1, 1),\n\n        // 3\n        S4(0, 1, 1, 1),\n\n        // 4\n        S4(0, 1, 1, 1),\n\n        // 5\n        S4(0, 1, 1, 1),\n\n        // 6\n        S4(0, 1, 1, 1),\n\n        // 7\n        S4(0, 1, 1, 1),\n\n        // 8\n        S4(0, 1, 1, 1),\n\n        //\n        // 展開2（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[HIHAT2_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 2, 2, 2, 2));\n\n    SEQUENCER(beat, time, KICK1_BEAT_LEN, KICK1_DEV_PAT, KICK1_DEV_LEN, notes, development, hihat2)\n    return ret;\n}\n\n//  CHORD  //\n//  CHORD  //\n//  CHORD  //\n\nvec2 introSupersaw1(float beat, float time) {\n    if (beat >= 64.0) return vec2(0.0);\n\n// 1つの展開のビート数\n#define INTROSAW_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define INTROSAW_DEV_PAT 2\n\n// 展開の長さ\n#define INTROSAW_DEV_LEN 8\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[INTROSAW_BEAT_LEN * NOTE_DIV * INTROSAW_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(45),\n\n        // 3\n        F(0),\n\n        // 4\n        F(45),\n\n        // 5\n        F(0),\n\n        // 6\n        F(45),\n\n        // 7\n        F(0),\n\n        // 8\n        F(45),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(45),\n\n        // 2\n        F(45),\n\n        // 3\n        F(45),\n\n        // 4\n        F(45),\n\n        // 5\n        F(45),\n\n        // 6\n        F(45),\n\n        // 7\n        F(45),\n\n        // 8\n        F(45));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[INTROSAW_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1));\n\n    SEQUENCER(beat, time, INTROSAW_BEAT_LEN, INTROSAW_DEV_PAT, INTROSAW_DEV_LEN, notes, development, basssaw1)\n    return ret;\n}\n\nvec2 introSupersaw2(float beat, float time) {\n    if (beat >= 64.0) return vec2(0.0);\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[INTROSAW_BEAT_LEN * NOTE_DIV * INTROSAW_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(0),\n\n        // 3\n        F(0),\n\n        // 4\n        F(69),\n\n        // 5\n        F(0),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(57),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(0),\n\n        // 3\n        F(0),\n\n        // 4\n        F(57),\n\n        // 5\n        F(0),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(57));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[INTROSAW_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1));\n\n    SEQUENCER(beat, time, INTROSAW_BEAT_LEN, INTROSAW_DEV_PAT, INTROSAW_DEV_LEN, notes, development, basssaw2)\n    return ret;\n}\n\n//  鬼のSUPERSAW  //\n//  鬼のSUPERSAW  //\n//  鬼のSUPERSAW  //\n\nvec2 chordSupersaw1(float beat, float time) {\n// 1つの展開のビート数\n#define CHORD1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define CHORD1_DEV_PAT 4\n\n// 展開の長さ\n#define CHORD1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[CHORD1_BEAT_LEN * NOTE_DIV * CHORD1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(69),\n\n        // 2\n        O(69),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(0),\n\n        // 3\n        E2(0, 67),\n\n        // 4\n        F(0),\n\n        // 5\n        E2(0, 67),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(0),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        F(67),\n\n        // 2\n        F(0),\n\n        // 3\n        E2(0, 67),\n\n        // 4\n        F(0),\n\n        // 5\n        E2(0, 67),\n\n        // 6\n        F(0),\n\n        // 7\n        E2(0, 67),\n\n        // 8\n        F(62));\n\n    // 展開 #define CHORD1_DEV_LEN 8　変える\n    int[CHORD1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(2, 2, 2, 2, 3, 3, 3, 3), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, CHORD1_BEAT_LEN, CHORD1_DEV_PAT, CHORD1_DEV_LEN, notes, development, chordsaw1)\n    return ret;\n}\n\nvec2 chordSupersaw2(float beat, float time) {\n// 1つの展開のビート数\n#define CHORD2_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define CHORD2_DEV_PAT 4\n\n// 展開の長さ\n#define CHORD2_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[CHORD2_BEAT_LEN * NOTE_DIV * CHORD2_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(72),\n\n        // 2\n        O(72),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(0),\n\n        // 3\n        E2(0, 62),\n\n        // 4\n        F(0),\n\n        // 5\n        E2(0, 62),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(0),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        F(62),\n\n        // 2\n        F(0),\n\n        // 3\n        E2(0, 62),\n\n        // 4\n        F(0),\n\n        // 5\n        E2(0, 62),\n\n        // 6\n        F(0),\n\n        // 7\n        E2(0, 62),\n\n        // 8\n        F(57));\n\n    // 展開 #define CHORD2_DEV_LEN 8　変える\n    int[CHORD2_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(2, 2, 2, 2, 3, 3, 3, 3), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, CHORD2_BEAT_LEN, CHORD2_DEV_PAT, CHORD2_DEV_LEN, notes, development, chordsaw1)\n    return ret;\n}\n\nvec2 chordSupersaw3(float beat, float time) {\n// 1つの展開のビート数\n#define CHORD3_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define CHORD3_DEV_PAT 4\n\n// 展開の長さ\n#define CHORD3_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[CHORD3_BEAT_LEN * NOTE_DIV * CHORD3_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(74),\n\n        // 2\n        O(74),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(0),\n\n        // 3\n        E2(0, 60),\n\n        // 4\n        F(0),\n\n        // 5\n        E2(0, 60),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(0),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        F(60),\n\n        // 2\n        F(0),\n\n        // 3\n        E2(0, 60),\n\n        // 4\n        F(0),\n\n        // 5\n        E2(0, 60),\n\n        // 6\n        F(0),\n\n        // 7\n        E2(0, 60),\n\n        // 8\n        F(54));\n\n    // 展開 #define CHORD3_DEV_LEN 8　変える\n    int[CHORD3_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(2, 2, 2, 2, 3, 3, 3, 3), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, CHORD3_BEAT_LEN, CHORD3_DEV_PAT, CHORD3_DEV_LEN, notes, development, chordsaw1)\n    return ret;\n}\n\nvec2 chordSupersaw4(float beat, float time) {\n// 1つの展開のビート数\n#define CHORD4_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define CHORD4_DEV_PAT 4\n\n// 展開の長さ\n#define CHORD4_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[CHORD4_BEAT_LEN * NOTE_DIV * CHORD4_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(79),\n\n        // 2\n        O(79),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        F(0),\n\n        // 3\n        E2(0, 57),\n\n        // 4\n        F(0),\n\n        // 5\n        E2(0, 57),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(0),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        F(57),\n\n        // 2\n        F(0),\n\n        // 3\n        E2(0, 57),\n\n        // 4\n        F(0),\n\n        // 5\n        E2(0, 57),\n\n        // 6\n        F(0),\n\n        // 7\n        E2(0, 57),\n\n        // 8\n        F(49));\n\n    // 展開 #define CHORD4_DEV_LEN 8　変える\n    int[CHORD4_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(2, 2, 2, 2, 3, 3, 3, 3), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0));\n\n    SEQUENCER(beat, time, CHORD4_BEAT_LEN, CHORD4_DEV_PAT, CHORD4_DEV_LEN, notes, development, chordsaw1)\n    return ret;\n}\n\nvec2 chordSquare1(float beat, float time) {\n// 1つの展開のビート数\n#define SQUARE1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define SQUARE1_DEV_PAT 4\n\n// 展開の長さ\n#define SQUARE1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[SQUARE1_BEAT_LEN * NOTE_DIV * SQUARE1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(67, 67, 0, 67),\n\n        // 2\n        S4(67, 0, 67, 67),\n\n        // 3\n        S4(67, 67, 0, 67),\n\n        // 4\n        S4(67, 0, 67, 67),\n\n        // 5\n        S4(67, 67, 0, 67),\n\n        // 6\n        S4(67, 0, 67, 67),\n\n        // 7\n        S4(67, 67, 0, 67),\n\n        // 8\n        S4(67, 0, 72, 72),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        S4(67, 67, 0, 67),\n\n        // 2\n        S4(67, 0, 67, 67),\n\n        // 3\n        S4(67, 67, 0, 67),\n\n        // 4\n        S4(67, 0, 67, 67),\n\n        // 5\n        S4(67, 67, 0, 67),\n\n        // 6\n        S4(67, 0, 67, 67),\n\n        // 7\n        S4(72, 72, 0, 72),\n\n        // 8\n        S4(0, 0, 72, 72),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        S4(72, 0, 0, 0),\n\n        // 2\n        S4(0, 0, 67, 0),\n\n        // 3\n        S4(0, 0, 0, 71),\n\n        // 4\n        S4(0, 0, 0, 0),\n\n        // 5\n        S4(72, 0, 0, 0),\n\n        // 6\n        S4(0, 0, 67, 0),\n\n        // 7\n        S4(0, 0, 0, 71),\n\n        // 8\n        S4(0, 0, 0, 0));\n\n    // 展開 #define SQUARE1_DEV_LEN 8　変える\n    int[SQUARE1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 1, 2, 2, 2), D8(3, 3, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, SQUARE1_BEAT_LEN, SQUARE1_DEV_PAT, SQUARE1_DEV_LEN, notes, development, chordsquare1)\n    return ret;\n}\n\nvec2 chordSquare2(float beat, float time) {\n// 1つの展開のビート数\n#define SQUARE2_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define SQUARE2_DEV_PAT 4\n\n// 展開の長さ\n#define SQUARE2_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[SQUARE2_BEAT_LEN * NOTE_DIV * SQUARE2_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(62, 62, 0, 62),\n\n        // 2\n        S4(62, 0, 62, 62),\n\n        // 3\n        S4(62, 62, 0, 62),\n\n        // 4\n        S4(62, 0, 62, 62),\n\n        // 5\n        S4(62, 62, 0, 62),\n\n        // 6\n        S4(62, 0, 62, 62),\n\n        // 7\n        S4(62, 62, 0, 62),\n\n        // 8\n        S4(62, 0, 67, 67),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        S4(62, 62, 0, 62),\n\n        // 2\n        S4(62, 0, 62, 62),\n\n        // 3\n        S4(62, 62, 0, 62),\n\n        // 4\n        S4(62, 0, 62, 62),\n\n        // 5\n        S4(62, 62, 0, 62),\n\n        // 6\n        S4(62, 0, 62, 62),\n\n        // 7\n        S4(67, 67, 0, 67),\n\n        // 8\n        S4(0, 0, 67, 67),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        S4(71, 71, 0, 71),\n\n        // 2\n        S4(71, 0, 71, 71),\n\n        // 3\n        S4(71, 71, 0, 71),\n\n        // 4\n        S4(71, 0, 71, 71),\n\n        // 5\n        S4(71, 71, 0, 71),\n\n        // 6\n        S4(71, 0, 71, 71),\n\n        // 7\n        S4(72, 72, 0, 72),\n\n        // 8\n        S4(0, 0, 72, 72));\n\n    // 展開 #define SQUARE2_DEV_LEN 8　変える\n    int[SQUARE2_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 1, 2, 3, 3), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, SQUARE2_BEAT_LEN, SQUARE2_DEV_PAT, SQUARE2_DEV_LEN, notes, development, chordsquare1)\n    return ret;\n}\n\nvec2 chordSquare3(float beat, float time) {\n// 1つの展開のビート数\n#define SQUARE3_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define SQUARE3_DEV_PAT 4\n\n// 展開の長さ\n#define SQUARE3_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[SQUARE3_BEAT_LEN * NOTE_DIV * SQUARE3_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(57, 57, 0, 57),\n\n        // 2\n        S4(57, 0, 57, 57),\n\n        // 3\n        S4(57, 57, 0, 57),\n\n        // 4\n        S4(57, 0, 57, 57),\n\n        // 5\n        S4(57, 57, 0, 57),\n\n        // 6\n        S4(57, 0, 57, 57),\n\n        // 7\n        S4(57, 57, 0, 57),\n\n        // 8\n        S4(57, 0, 59, 59),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        S4(57, 57, 0, 57),\n\n        // 2\n        S4(57, 0, 57, 57),\n\n        // 3\n        S4(57, 57, 0, 57),\n\n        // 4\n        S4(57, 0, 57, 57),\n\n        // 5\n        S4(57, 57, 0, 57),\n\n        // 6\n        S4(57, 0, 57, 57),\n\n        // 7\n        S4(57, 57, 0, 57),\n\n        // 8\n        S4(0, 0, 57, 57),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        S4(0, 0, 0, 71),\n\n        // 2\n        S4(0, 0, 0, 0),\n\n        // 3\n        S4(72, 0, 0, 0),\n\n        // 4\n        S4(0, 0, 67, 0),\n\n        // 5\n        S4(0, 0, 0, 71),\n\n        // 6\n        S4(0, 0, 0, 0),\n\n        // 7\n        S4(72, 0, 0, 0),\n\n        // 8\n        S4(0, 0, 67, 0));\n\n    // 展開 #define SQUARE3_DEV_LEN 8　変える\n    int[SQUARE3_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 1, 2, 2, 2), D8(3, 3, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, SQUARE3_BEAT_LEN, SQUARE3_DEV_PAT, SQUARE3_DEV_LEN, notes, development, chordsquare1)\n    return ret;\n}\n\nvec2 snare1(float beat, float time) {\n// 1つの展開のビート数\n#define SNARE1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define SNARE1_DEV_PAT 2\n\n// 展開の長さ\n#define SNARE1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[SNARE1_BEAT_LEN * NOTE_DIV * SNARE1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(0),\n\n        // 2\n        E2(1, 0),\n\n        // 3\n        F(0),\n\n        // 4\n        E2(1, 0),\n\n        // 5\n        F(0),\n\n        // 6\n        E2(1, 0),\n\n        // 7\n        F(0),\n\n        // 8\n        E2(1, 0));\n\n    // 展開 #define SNARE1_DEV_LEN 8　変える\n    int[SNARE1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, SNARE1_BEAT_LEN, SNARE1_DEV_PAT, SNARE1_DEV_LEN, notes, development, snare)\n    return ret;\n}\n\n//\n// hokkSUpersaw1は79のみを再生する\n//\n\nvec2 hookSupersaw1(float beat, float time) {\n// 1つの展開のビート数\n#define HOOK1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define HOOK1_DEV_PAT 2\n\n// 展開の長さ\n#define HOOK1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[HOOK1_BEAT_LEN * NOTE_DIV * HOOK1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1\n        //\n\n        // 1\n        F(79),\n\n        // 2\n        S4(79, 79, 79, 79),\n\n        // 3\n        S4(79, 79, 79, 79),\n\n        // 4\n        S4(79, 79, 79, 79),\n\n        // 5\n        F(79),\n\n        // 6\n        S4(79, 79, 79, 79),\n\n        // 7\n        S4(79, 79, 79, 79),\n\n        // 8\n        S4(79, 79, 79, 79));\n\n    // 展開 #define HOOK1_DEV_LEN 8　変える\n    int[HOOK1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, HOOK1_BEAT_LEN, HOOK1_DEV_PAT, HOOK1_DEV_LEN, notes, development, chordsaw2)\n    return ret;\n}\n\nvec2 hookSupersaw2(float beat, float time) {\n// 1つの展開のビート数\n#define HOOK2_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define HOOK2_DEV_PAT 4\n\n// 展開の長さ\n#define HOOK2_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[HOOK2_BEAT_LEN * NOTE_DIV * HOOK2_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1\n        //\n\n        // 1\n        F(74),\n\n        // 2\n        S4(74, 74, 74, 74),\n\n        // 3\n        S4(74, 74, 74, 74),\n\n        // 4\n        S4(74, 74, 74, 74),\n\n        // 5\n        F(74),\n\n        // 6\n        S4(74, 74, 74, 74),\n\n        // 7\n        S4(74, 74, 74, 74),\n\n        // 8\n        S4(74, 74, 74, 74),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        F(74),\n\n        // 2\n        S4(74, 74, 74, 74),\n\n        // 3\n        S4(74, 74, 74, 74),\n\n        // 4\n        S4(74, 74, 74, 74),\n\n        // 5\n        F(86),\n\n        // 6\n        S4(86, 86, 86, 86),\n\n        // 7\n        S4(86, 86, 86, 86),\n\n        // 8\n        S4(86, 86, 86, 86),\n\n        //\n        // 展開3 HOOK 8小節目に使用\n        //\n\n        // 1\n        F(74),\n\n        // 2\n        S4(74, 74, 74, 74),\n\n        // 3\n        S4(74, 74, 74, 74),\n\n        // 4\n        S4(74, 74, 74, 74),\n\n        // 5\n        F(76),\n\n        // 6\n        S4(76, 76, 76, 76),\n\n        // 7\n        S4(76, 76, 76, 76),\n\n        // 8\n        S4(76, 76, 76, 76));\n\n    // 展開 #define HOOK2_DEV_LEN 8　変える\n    int[HOOK2_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 2, 1, 3, 1, 1, 1, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, HOOK2_BEAT_LEN, HOOK2_DEV_PAT, HOOK2_DEV_LEN, notes, development, chordsaw2)\n    return ret;\n}\n\nvec2 hookSupersaw3(float beat, float time) {\n// 1つの展開のビート数\n#define HOOK3_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define HOOK3_DEV_PAT 8\n\n// 展開の長さ\n#define HOOK3_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[HOOK3_BEAT_LEN * NOTE_DIV * HOOK3_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1\n        //\n\n        // 1\n        F(57),\n\n        // 2\n        S4(57, 57, 57, 57),\n\n        // 3\n        S4(57, 57, 57, 57),\n\n        // 4\n        S4(57, 57, 57, 57),\n\n        // 5\n        F(57),\n\n        // 6\n        S4(57, 57, 57, 57),\n\n        // 7\n        S4(57, 57, 57, 57),\n\n        // 8\n        S4(84, 84, 84, 84),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        F(83),\n\n        // 2\n        S4(83, 83, 83, 83),\n\n        // 3\n        S4(83, 83, 83, 83),\n\n        // 4\n        S4(83, 83, 83, 83),\n\n        // 5\n        F(83),\n\n        // 6\n        S4(83, 83, 83, 83),\n\n        // 7\n        S4(83, 83, 83, 83),\n\n        // 8\n        S4(83, 83, 83, 83),\n\n        //\n        // 展開3 HOOK 7～8小節目に使用\n        //\n\n        // 1\n        F(83),\n\n        // 2\n        S4(83, 83, 83, 83),\n\n        // 3\n        S4(83, 83, 83, 83),\n\n        // 4\n        S4(83, 83, 83, 83),\n\n        // 5\n        F(88),\n\n        // 6\n        S4(88, 88, 88, 88),\n\n        // 7\n        S4(91, 91, 91, 91),\n\n        // 8\n        S4(91, 91, 91, 91),\n\n        //\n        // 展開4 HOOK 9～小節目に使用\n        //\n\n        // 1\n        F(79),\n\n        // 2\n        S4(79, 79, 79, 79),\n\n        // 3\n        S4(79, 79, 79, 79),\n\n        // 4\n        S4(79, 79, 79, 79),\n\n        // 5\n        F(79),\n\n        // 6\n        S4(79, 79, 79, 79),\n\n        // 7\n        S4(79, 79, 79, 79),\n\n        // 8\n        S4(72, 72, 72, 72),\n\n        //\n        // 展開5 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(83),\n\n        // 2\n        S4(83, 83, 83, 83),\n\n        // 3\n        S4(83, 83, 83, 83),\n\n        // 4\n        S4(83, 83, 83, 83),\n\n        // 5\n        F(79),\n\n        // 2\n        S4(79, 79, 79, 79),\n\n        // 3\n        S4(79, 79, 79, 79),\n\n        // 4\n        S4(79, 79, 79, 79),\n\n        //\n        // 展開6 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(79),\n\n        // 2\n        S4(79, 79, 79, 79),\n\n        // 3\n        S4(79, 79, 79, 79),\n\n        // 4\n        S4(79, 79, 79, 79),\n\n        // 5\n        F(79),\n\n        // 2\n        S4(79, 79, 79, 79),\n\n        // 3\n        S4(79, 79, 79, 79),\n\n        // 4\n        S4(79, 79, 79, 79),\n\n        //\n        // 展開7 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(83),\n\n        // 2\n        S4(83, 83, 83, 83),\n\n        // 3\n        S4(83, 83, 83, 83),\n\n        // 4\n        S4(83, 83, 83, 83),\n\n        // 5\n        F(86),\n\n        // 6\n        S4(86, 86, 86, 86),\n\n        // 7\n        S4(86, 86, 86, 86),\n\n        // 8\n        S4(86, 86, 86, 86));\n\n    // 展開 #define HOOK3_DEV_LEN 8　変える\n    int[HOOK3_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 2, 1, 3, 4, 5, 6, 7), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, HOOK3_BEAT_LEN, HOOK3_DEV_PAT, HOOK3_DEV_LEN, notes, development, chordsaw2)\n    return ret;\n}\n\nvec2 hookSupersaw4(float beat, float time) {\n// 1つの展開のビート数\n#define HOOK4_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define HOOK4_DEV_PAT 6\n\n// 展開の長さ\n#define HOOK4_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[HOOK4_BEAT_LEN * NOTE_DIV * HOOK4_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1\n        //\n\n        // 1\n        F(71),\n\n        // 2\n        S4(71, 71, 71, 71),\n\n        // 3\n        S4(71, 71, 71, 71),\n\n        // 4\n        S4(71, 71, 71, 71),\n\n        // 5\n        F(71),\n\n        // 6\n        S4(71, 71, 71, 71),\n\n        // 7\n        S4(71, 71, 71, 71),\n\n        // 8\n        S4(71, 71, 71, 71),\n\n        //\n        // 展開4 HOOK 9～小節目に使用\n        //\n\n        // 1\n        F(91),\n\n        // 2\n        S4(91, 91, 91, 91),\n\n        // 3\n        S4(91, 91, 91, 91),\n\n        // 4\n        S4(91, 91, 91, 91),\n\n        // 5\n        F(91),\n\n        // 6\n        S4(91, 91, 91, 91),\n\n        // 7\n        S4(91, 91, 91, 91),\n\n        // 8\n        S4(84, 84, 84, 84),\n\n        //\n        // 展開5 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(95),\n\n        // 2\n        S4(95, 95, 95, 95),\n\n        // 3\n        S4(95, 95, 95, 95),\n\n        // 4\n        S4(95, 95, 95, 95),\n\n        // 5\n        F(91),\n\n        // 2\n        S4(91, 91, 91, 91),\n\n        // 3\n        S4(91, 91, 91, 91),\n\n        // 4\n        S4(91, 91, 91, 91),\n\n        //\n        // 展開6 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(91),\n\n        // 2\n        S4(91, 91, 91, 91),\n\n        // 3\n        S4(91, 91, 91, 91),\n\n        // 4\n        S4(91, 91, 91, 91),\n\n        // 5\n        F(91),\n\n        // 2\n        S4(91, 91, 91, 91),\n\n        // 3\n        S4(91, 91, 91, 91),\n\n        // 4\n        S4(91, 91, 91, 91),\n\n        //\n        // 展開7 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(95),\n\n        // 2\n        S4(95, 95, 95, 95),\n\n        // 3\n        S4(95, 95, 95, 95),\n\n        // 4\n        S4(95, 95, 95, 95),\n\n        // 5\n        F(98),\n\n        // 6\n        S4(98, 98, 98, 98),\n\n        // 7\n        S4(98, 98, 98, 98),\n\n        // 8\n        S4(98, 98, 98, 98));\n\n    // 展開 #define HOOK4_DEV_LEN 8　変える\n    int[HOOK4_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 1, 2, 3, 4, 5), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, HOOK4_BEAT_LEN, HOOK4_DEV_PAT, HOOK4_DEV_LEN, notes, development, chordsaw2)\n    return ret;\n}\n\nvec2 hookSupersaw5(float beat, float time) {\n// 1つの展開のビート数\n#define HOOK3_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define HOOK3_DEV_PAT 8\n\n// 展開の長さ\n#define HOOK3_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[HOOK3_BEAT_LEN * NOTE_DIV * HOOK3_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1\n        //\n\n        // 1\n        F(57),\n\n        // 2\n        S4(57, 57, 57, 57),\n\n        // 3\n        S4(57, 57, 57, 57),\n\n        // 4\n        S4(57, 57, 57, 57),\n\n        // 5\n        F(57),\n\n        // 6\n        S4(57, 57, 57, 57),\n\n        // 7\n        S4(57, 57, 57, 57),\n\n        // 8\n        S4(84, 84, 84, 84),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        F(71),\n\n        // 2\n        S4(71, 71, 71, 71),\n\n        // 3\n        S4(71, 71, 71, 71),\n\n        // 4\n        S4(71, 71, 71, 71),\n\n        // 5\n        F(83),\n\n        // 6\n        S4(71, 71, 71, 71),\n\n        // 7\n        S4(71, 71, 71, 71),\n\n        // 8\n        S4(71, 71, 71, 71),\n\n        //\n        // 展開3 HOOK 7～8小節目に使用\n        //\n\n        // 1\n        F(71),\n\n        // 2\n        S4(71, 71, 71, 71),\n\n        // 3\n        S4(71, 71, 71, 71),\n\n        // 4\n        S4(71, 71, 71, 71),\n\n        // 5\n        F(76),\n\n        // 6\n        S4(76, 76, 76, 76),\n\n        // 7\n        S4(79, 79, 79, 79),\n\n        // 8\n        S4(79, 79, 79, 79),\n\n        //\n        // 展開4 HOOK 9～小節目に使用\n        //\n\n        // 1\n        F(67),\n\n        // 2\n        S4(67, 67, 67, 67),\n\n        // 3\n        S4(67, 67, 67, 67),\n\n        // 4\n        S4(67, 67, 67, 67),\n\n        // 5\n        F(67),\n\n        // 6\n        S4(67, 67, 67, 67),\n\n        // 7\n        S4(67, 67, 67, 67),\n\n        // 8\n        S4(60, 60, 60, 60),\n\n        //\n        // 展開5 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(71),\n\n        // 2\n        S4(71, 71, 71, 71),\n\n        // 3\n        S4(71, 71, 71, 71),\n\n        // 4\n        S4(71, 71, 71, 71),\n\n        // 5\n        F(67),\n\n        // 2\n        S4(67, 67, 67, 67),\n\n        // 3\n        S4(67, 67, 67, 67),\n\n        // 4\n        S4(69, 69, 69, 69),\n\n        //\n        // 展開6 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(67),\n\n        // 2\n        S4(67, 67, 67, 67),\n\n        // 3\n        S4(67, 67, 67, 67),\n\n        // 4\n        S4(67, 67, 67, 67),\n\n        // 5\n        F(67),\n\n        // 2\n        S4(67, 67, 67, 67),\n\n        // 3\n        S4(67, 67, 67, 67),\n\n        // 4\n        S4(72, 72, 72, 72),\n\n        //\n        // 展開7 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(71),\n\n        // 2\n        S4(71, 71, 71, 71),\n\n        // 3\n        S4(71, 71, 71, 71),\n\n        // 4\n        S4(71, 71, 71, 71),\n\n        // 5\n        F(74),\n\n        // 6\n        S4(74, 74, 74, 74),\n\n        // 7\n        S4(74, 74, 74, 74),\n\n        // 8\n        S4(74, 74, 74, 74));\n\n    // 展開 #define HOOK3_DEV_LEN 8　変える\n    int[HOOK3_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 2, 1, 3, 4, 5, 6, 7), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, HOOK3_BEAT_LEN, HOOK3_DEV_PAT, HOOK3_DEV_LEN, notes, development, leadsub)\n    return ret;\n}\n\nvec2 hookSupersaw6(float beat, float time) {\n// 1つの展開のビート数\n#define HOOK3_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define HOOK3_DEV_PAT 8\n\n// 展開の長さ\n#define HOOK3_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[HOOK3_BEAT_LEN * NOTE_DIV * HOOK3_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1\n        //\n\n        // 1\n        F(45),\n\n        // 2\n        S4(45, 45, 45, 45),\n\n        // 3\n        S4(45, 45, 45, 45),\n\n        // 4\n        S4(45, 45, 45, 45),\n\n        // 5\n        F(45),\n\n        // 6\n        S4(45, 45, 45, 45),\n\n        // 7\n        S4(45, 45, 45, 45),\n\n        // 8\n        S4(72, 72, 72, 72),\n\n        //\n        // 展開2\n        //\n\n        // 1\n        F(59),\n\n        // 2\n        S4(59, 59, 59, 59),\n\n        // 3\n        S4(59, 59, 59, 59),\n\n        // 4\n        S4(59, 59, 59, 59),\n\n        // 5\n        F(71),\n\n        // 6\n        S4(59, 59, 59, 59),\n\n        // 7\n        S4(59, 59, 59, 59),\n\n        // 8\n        S4(59, 59, 59, 59),\n\n        //\n        // 展開3 HOOK 7～8小節目に使用\n        //\n\n        // 1\n        F(59),\n\n        // 2\n        S4(59, 59, 59, 59),\n\n        // 3\n        S4(59, 59, 59, 59),\n\n        // 4\n        S4(59, 59, 59, 59),\n\n        // 5\n        F(64),\n\n        // 6\n        S4(64, 64, 64, 64),\n\n        // 7\n        S4(67, 67, 67, 67),\n\n        // 8\n        S4(67, 67, 67, 67),\n\n        //\n        // 展開4 HOOK 9～小節目に使用\n        //\n\n        // 1\n        F(67),\n\n        // 2\n        S4(67, 67, 67, 67),\n\n        // 3\n        S4(67, 67, 67, 67),\n\n        // 4\n        S4(67, 67, 67, 67),\n\n        // 5\n        F(67),\n\n        // 6\n        S4(67, 67, 67, 67),\n\n        // 7\n        S4(67, 67, 67, 67),\n\n        // 8\n        S4(48, 48, 48, 48),\n\n        //\n        // 展開5 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(59),\n\n        // 2\n        S4(59, 59, 59, 59),\n\n        // 3\n        S4(59, 59, 59, 59),\n\n        // 4\n        S4(59, 59, 59, 59),\n\n        // 5\n        F(67),\n\n        // 2\n        S4(67, 67, 67, 67),\n\n        // 3\n        S4(67, 67, 67, 67),\n\n        // 4\n        S4(57, 57, 57, 57),\n\n        //\n        // 展開6 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(67),\n\n        // 2\n        S4(67, 67, 67, 67),\n\n        // 3\n        S4(67, 67, 67, 67),\n\n        // 4\n        S4(67, 67, 67, 67),\n\n        // 5\n        F(67),\n\n        // 2\n        S4(67, 67, 67, 67),\n\n        // 3\n        S4(67, 67, 67, 67),\n\n        // 4\n        S4(72, 72, 72, 72),\n\n        //\n        // 展開7 HOOK 11～小節目に使用\n        //\n\n        // 1\n        F(59),\n\n        // 2\n        S4(59, 59, 59, 59),\n\n        // 3\n        S4(59, 59, 59, 59),\n\n        // 4\n        S4(59, 59, 59, 59),\n\n        // 5\n        F(62),\n\n        // 6\n        S4(62, 62, 62, 62),\n\n        // 7\n        S4(62, 62, 62, 62),\n\n        // 8\n        S4(62, 62, 62, 62));\n\n    // 展開 #define HOOK3_DEV_LEN 8　変える\n    int[HOOK3_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(1, 2, 1, 3, 4, 5, 6, 7), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, HOOK3_BEAT_LEN, HOOK3_DEV_PAT, HOOK3_DEV_LEN, notes, development, leadsub)\n    return ret;\n}\n\nvec2 snare2(float beat, float time) {\n// 1つの展開のビート数\n#define SNARE1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define SNARE1_DEV_PAT 2\n\n// 展開の長さ\n#define SNARE1_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[SNARE1_BEAT_LEN * NOTE_DIV * SNARE1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(1, 1, 1, 1),\n\n        // 2\n        S4(1, 1, 1, 1),\n\n        // 3\n        S4(1, 1, 1, 1),\n\n        // 4\n        S4(1, 1, 1, 1),\n\n        // 5\n        S4(1, 1, 1, 1),\n\n        // 6\n        S4(1, 1, 1, 1),\n\n        // 7\n        S4(1, 1, 1, 1),\n\n        // 8\n        S4(1, 1, 1, 1));\n\n    // 展開 #define SNARE1_DEV_LEN 8　変える\n    int[SNARE1_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 0, 0, 0, 0, 1, 1), D8(0, 0, 0, 0, 0, 0, 1, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, SNARE1_BEAT_LEN, SNARE1_DEV_PAT, SNARE1_DEV_LEN, notes, development, snarefill)\n    return ret;\n}\n\nvec2 noisefeed(float beat, float time) {\n// 1つの展開のビート数\n#define FEED_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define FEED_DEV_PAT 3\n\n// 展開の長さ\n#define FEED_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[FEED_BEAT_LEN * NOTE_DIV * FEED_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1~4\n        O(0),\n\n        // 5\n        F(1),\n\n        // 6\n        F(1),\n\n        // 7\n        F(1),\n\n        // 8\n        F(1),\n\n        //\n        // 展開3\n        //\n\n        // 1\n        O(1),\n\n        // 2\n        O(0));\n\n    // 展開 #define SNARE1_DEV_LEN 8　変える\n    int[FEED_DEV_LEN / DEV_PACK] development = int[](D8(2, 0, 2, 1, 2, 0, 0, 1), D8(2, 0, 0, 0, 2, 0, 0, 1), D8(2, 0, 0, 0, 2, 0, 0, 1), D8(2, 0, 0, 0, 2, 0, 0, 0));\n    SEQUENCER(beat, time, FEED_BEAT_LEN, FEED_DEV_PAT, FEED_DEV_LEN, notes, development, noisefeedin)\n    return ret;\n}\n\nvec2 noisesidechain1(float beat, float time) {\n// 1つの展開のビート数\n#define NOISESIDE_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define NOISESIDE_DEV_PAT 2\n\n// 展開の長さ\n#define NOISESIDE_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[NOISESIDE_BEAT_LEN * NOTE_DIV * NOISESIDE_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(1),\n\n        // 2\n        F(1),\n\n        // 3\n        F(1),\n\n        // 4\n        F(1),\n\n        // 5\n        F(1),\n\n        // 6\n        F(1),\n\n        // 7\n        F(1),\n\n        // 8\n        F(1));\n\n    // 展開 #define SNARE1_DEV_LEN 8　変える\n    int[NOISESIDE_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 1, 1, 1), D8(0, 0, 0, 0, 1, 1, 0, 0), D8(1, 1, 1, 1, 1, 1, 1, 1), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, NOISESIDE_BEAT_LEN, NOISESIDE_DEV_PAT, NOISESIDE_DEV_LEN, notes, development, sidechainnoise)\n    return ret;\n}\n\nvec2 noisesidechain2(float beat, float time) {\n// 1つの展開のビート数 L\n#define NOISESIDE_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define NOISESIDE_DEV_PAT 2\n\n// 展開の長さ\n#define NOISESIDE_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[NOISESIDE_BEAT_LEN * NOTE_DIV * NOISESIDE_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(1),\n\n        // 2\n        O(0));\n\n    // 展開 #define SNARE1_DEV_LEN 8　変える\n    int[NOISESIDE_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 1, 0, 0, 0), D8(1, 0, 0, 0, 0, 0, 0, 0), D8(1, 0, 0, 0, 1, 0, 0, 0), D8(1, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, NOISESIDE_BEAT_LEN, NOISESIDE_DEV_PAT, NOISESIDE_DEV_LEN, notes, development, sidechainnoise2)\n    return ret;\n}\n\nvec2 noisesidechain3(float beat, float time) {\n// 1つの展開のビート数 L\n#define NOISESIDE_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define NOISESIDE_DEV_PAT 2\n\n// 展開の長さ\n#define NOISESIDE_DEV_LEN 32\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[NOISESIDE_BEAT_LEN * NOTE_DIV * NOISESIDE_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        O(0),\n\n        // 2\n        O(0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        O(1),\n\n        // 2\n        O(0));\n\n    // 展開 #define SNARE1_DEV_LEN 8　変える\n    int[NOISESIDE_DEV_LEN / DEV_PACK] development = int[](D8(0, 0, 0, 0, 0, 0, 1, 0), D8(0, 0, 0, 0, 0, 0, 0, 0), D8(0, 0, 1, 0, 0, 0, 1, 0), D8(0, 0, 0, 0, 0, 0, 0, 0));\n    SEQUENCER(beat, time, NOISESIDE_BEAT_LEN, NOISESIDE_DEV_PAT, NOISESIDE_DEV_LEN, notes, development, sidechainnoise2)\n    return ret;\n}\n\nvec2 mainSound(float time) {\n    //編集用に時間を途中からすすめる\n    time += 0.0;\n\n    float beat = timeToBeat(time);\n    vec2 ret = vec2(0.0);\n\n    // kick\n    ret += vec2(0.8) * kick1(beat, time);\n    ret += vec2(0.4, 0.15) * crashcymbal1(beat, time);  // L70 R0\n    ret += vec2(0.15, 0.4) * crashcymbal2(beat, time);  // L70 R0\n\n    // hihat\n    ret += vec2(0.0, 0.5) * sidechain * hihat33(beat, time);\n    ret += vec2(0.4, 0.2) * sidechain * testhihat2(beat, time);\n\n    ret += vec2(0.5) * sidechain4 * bass1(beat, time);         // L70 R0\n    ret += vec2(0.19, 0.19) * sidechain4 * bass2(beat, time);  // L70 R0\n    ret += vec2(0.01) * sidechain4 * bass3(beat, time);\n    ret += vec2(0.2, 0.15) * sidechain2 * sideSupersaw1(beat, time);  // ベースの補強\n    ret += vec2(0.15, 0.2) * sidechain2 * sideSupersaw2(beat, time);  // ベースの補強\n    ret += vec2(0.05, 0.05) * sidechain * tb303synth(beat, time);     // ベースの補強\n\n    // arp\n    ret += vec2(0.1, 0.1) * sidechain * subbass1(beat, time);          // サブベース\n    ret += vec2(0.15) * sidechain * arp0(beat, time);                  //\n    ret += vec2(0.35, 0.0) * sidechain2 * arp1(beat, time);            //\n    ret += vec2(0.0, 0.35) * sidechain2 * arp2(beat, time);            //\n    ret += vec2(0.3, 1.0) * sidechain2 * arp3(beat, time);             // サイン波のアルペジオ\n    ret += vec2(1.0, 0.3) * sidechain2 * arp4(beat, time);             //  サイン波のアルペジオ\n    ret += vec2(0.4, 0.2) * sidechain2 * chordSupersaw1(beat, time);   // コード\n    ret += vec2(0.3) * sidechain2 * chordSupersaw2(beat, time);        // コード\n    ret += vec2(0.3, 0.12) * sidechain2 * chordSupersaw3(beat, time);  // コード\n    ret += vec2(0.4, 0.2) * sidechain2 * chordSupersaw4(beat, time);   // コード\n\n    ret += vec2(0.4) * sidechain5 * noisesidechain1(beat, time);\n    ret += vec2(0.2, 0.05) * sidechain5 * noisesidechain2(beat, time);\n    ret += vec2(0.05, 0.2) * sidechain5 * noisesidechain3(beat, time);\n\n    ret += vec2(0.4) * sidechain * arp5(beat, time);                // アルペジオ中央\n    ret += vec2(0.1, 0.3) * sidechain2 * chordSquare1(beat, time);  //\n    ret += vec2(0.3) * sidechain2 * chordSquare2(beat, time);       //\n    ret += vec2(0.3, 0.1) * sidechain2 * chordSquare3(beat, time);  //\n\n    // supersaw\n    ret += vec2(0.05, 0.2) * sidechain * introSupersaw1(beat, time);\n    ret += vec2(0.2, 0.05) * sidechain2 * introSupersaw2(beat, time);\n    ret += vec2(0.3, 0.15) * sidechain * hookSupersaw1(beat, time);\n    ret += vec2(0.4) * sidechain * hookSupersaw2(beat, time);\n    ret += vec2(0.10, 0.2) * sidechain * hookSupersaw3(beat, time);\n    ret += vec2(0.2, 0.05) * sidechain * hookSupersaw4(beat, time);\n    ret += vec2(0.13) * sidechain * hookSupersaw5(beat, time);\n    ret += vec2(0.02, 0.05) * sidechain * hookSupersaw6(beat, time);\n\n    // ここまでの音をMute\n    // ret = vec2(0.0);\n\n    // snare\n    ret += vec2(0.2) * snare1(beat, time);\n    ret += vec2(0.1) * snare2(beat, time);\n    ret += vec2(0.37, 0.3) * sidechain2 * noisefeed(beat, time);\n\n    return clamp(ret, -1.0, 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="body{background-color:#000;margin:0;padding:0;color:#fff}#c{display:none}canvas{display:block;position:absolute;top:0;left:0;right:0;bottom:0;margin:auto}.container{display:flex;justify-content:center;align-items:center;width:100%;height:100%}p{font-size:100px;text-align:center}.lds-facebook{display:inline-block;position:relative;width:80px;height:80px}.lds-facebook div{display:inline-block;position:absolute;left:8px;width:16px;background:#fff;animation:lds-facebook 1.2s cubic-bezier(0,.5,.5,1) infinite}.lds-facebook div:nth-child(1){left:8px;animation-delay:-.24s}.lds-facebook div:nth-child(2){left:32px;animation-delay:-.12s}.lds-facebook div:nth-child(3){left:56px;animation-delay:0}@keyframes lds-facebook{0%{top:8px;height:64px}100%,50%{top:24px;height:32px}}"},function(n,e,t){"use strict";t.r(e);var i=function(n,e,t,i){return new(t||(t=Promise))((function(o,a){function r(n){try{c(i.next(n))}catch(n){a(n)}}function s(n){try{c(i.throw(n))}catch(n){a(n)}}function c(n){var e;n.done?o(n.value):(e=n.value,e instanceof t?e:new t((function(n){n(e)}))).then(r,s)}c((i=i.apply(n,e||[])).next())}))},o=function(n,e){var t,i,o,a,r={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(t)throw new TypeError("Generator is already executing.");for(;r;)try{if(t=1,i&&(o=2&a[0]?i.return:a[0]?i.throw||((o=i.return)&&o.call(i),0):i.next)&&!(o=o.call(i,a[1])).done)return o;switch(i=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return r.label++,{value:a[1],done:!1};case 5:r.label++,i=a[1],a=[0];continue;case 7:a=r.ops.pop(),r.trys.pop();continue;default:if(!(o=(o=r.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){r=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){r.label=a[1];break}if(6===a[0]&&r.label<o[1]){r.label=o[1],o=a;break}if(o&&r.label<o[2]){r.label=o[2],r.ops.push(a);break}o[2]&&r.ops.pop(),r.trys.pop();continue}a=e.call(n,r)}catch(n){a=[6,n],i=0}finally{t=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}},a=0,r=1,s=2,c=3,l=4,f=function(){},m=function(n,e,t,m,E,u,d,v,S,p,_,h){var g=this,A=function(n){return new Promise((function(e){return setTimeout(e,n)}))};this.init=function(){return i(g,void 0,void 0,(function(){var g,T,D,x,b,N,y,R,F,P,O,C,I,L,V,B,w,H,U,M,K,z,q=this;return o(this,(function(k){switch(k.label){case 0:return this.timeLength=n,this.isPlaying=!0,this.needsUpdate=!1,this.time=0,this.debugFrameNumber=-1,this.uniformArray=[],this.uniforms={},g=this.audioContext=new window.AudioContext,(T=this.canvas=document.createElement("canvas")).width=window.innerWidth,T.height=window.innerHeight,window.document.body.appendChild(T),(D=T.getContext("webgl2",{preserveDrawingBuffer:!0}))?D.getExtension("EXT_color_buffer_float")?D.getExtension("OES_texture_float_linear")?(D.enable(D.CULL_FACE),x=[[1,1],[-1,1],[1,-1],[-1,-1]],b=new Float32Array([].concat.apply([],x)),N=D.createBuffer(),D.bindBuffer(D.ARRAY_BUFFER,N),D.bufferData(D.ARRAY_BUFFER,b,D.STATIC_DRAW),D.bindBuffer(D.ARRAY_BUFFER,null),y=[[0,1,2],[3,2,1]],R=new Uint16Array([].concat.apply([],y)),F=D.createBuffer(),D.bindBuffer(D.ELEMENT_ARRAY_BUFFER,F),D.bufferData(D.ELEMENT_ARRAY_BUFFER,R,D.STATIC_DRAW),D.bindBuffer(D.ELEMENT_ARRAY_BUFFER,null),P=D.createVertexArray(),O=function(n){D.bindVertexArray(P),D.bindBuffer(D.ARRAY_BUFFER,N),D.bindBuffer(D.ELEMENT_ARRAY_BUFFER,F);var e=D.getAttribLocation(n,"vert2d"),t=D.FLOAT,i=x[0].length,o=i*Float32Array.BYTES_PER_ELEMENT;D.enableVertexAttribArray(e),D.vertexAttribPointer(e,i,t,!1,o,0),D.bindVertexArray(null)},C=h(D),t.split("\n").length,I=function(n,e){var t=D.createShader(e);if(D.shaderSource(t,n),D.compileShader(t),!D.getShaderParameter(t,D.COMPILE_STATUS)){var i=D.getShaderInfoLog(t);console.log(n,i)}return t},L=function(n){var t=[I(e,D.VERTEX_SHADER),I(n,D.FRAGMENT_SHADER)],i=D.createProgram();return t.forEach((function(n){return D.attachShader(i,n)})),D.linkProgram(i),D.getProgramParameter(i,D.LINK_STATUS)||console.log(D.getProgramInfoLog(i)),i},V=function(n){var e={};return Object.keys(n.uniforms).forEach((function(t){e[t]=D.getUniformLocation(n.program,t)})),e},B=function(n){if(n.type!==r){var e=n.uniforms.iResolution.value[0],t=n.uniforms.iResolution.value[1],i=D.FLOAT,o=D.RGBA32F,a=D.LINEAR;n.type===l&&(e=512,t=512,i=D.UNSIGNED_BYTE,o=D.RGBA,a=D.NEAREST),n.frameBuffer=D.createFramebuffer(),D.bindFramebuffer(D.FRAMEBUFFER,n.frameBuffer),n.texture=D.createTexture(),D.bindTexture(D.TEXTURE_2D,n.texture),D.texImage2D(D.TEXTURE_2D,0,o,e,t,0,D.RGBA,i,null),D.texParameteri(D.TEXTURE_2D,D.TEXTURE_MAG_FILTER,a),D.texParameteri(D.TEXTURE_2D,D.TEXTURE_MIN_FILTER,a),D.texParameteri(D.TEXTURE_2D,D.TEXTURE_WRAP_S,D.CLAMP_TO_EDGE),D.texParameteri(D.TEXTURE_2D,D.TEXTURE_WRAP_T,D.CLAMP_TO_EDGE),D.framebufferTexture2D(D.FRAMEBUFFER,D.COLOR_ATTACHMENT0,D.TEXTURE_2D,n.texture,0),D.bindTexture(D.TEXTURE_2D,null),D.bindRenderbuffer(D.RENDERBUFFER,null),D.bindFramebuffer(D.FRAMEBUFFER,null)}},w=function(n,e,t,i){O(n);var o=new f;if(o.program=n,o.index=e,o.type=t,o.scale=i,o.uniforms={iResolution:{type:"v3",value:[T.width*o.scale,T.height*o.scale,0]},iTime:{type:"f",value:0},iPrevPass:{type:"t",value:Math.max(o.index-1,0)},iBeforeBloom:{type:"t",value:Math.max(E-1,0)},iBlockOffset:{type:"f",value:0},iSampleRate:{type:"f",value:g.sampleRate},iTextTexture:{type:"t",value:0}},t===c){var a=e-(E+u);o.uniforms.iPairBloomDown={type:"t",value:e-2*a}}return q.uniformArray.forEach((function(n){o.uniforms[n.key]={type:"number"==typeof n.initValue?"f":"v3",value:n.initValue}})),o.locations=V(o),B(o),o},H=function(n){D.useProgram(n.program),D.bindFramebuffer(D.FRAMEBUFFER,n.frameBuffer),D.clear(D.COLOR_BUFFER_BIT|D.DEPTH_BUFFER_BIT);for(var e=0,t=Object.entries(n.uniforms);e<t.length;e++){var i=t[e],o=i[0],a=i[1],r={f:D.uniform1f,v3:D.uniform3fv},s={iPrevPass:0,iBeforeBloom:1,iPairBloomDown:2,iTextTexture:3};"t"===a.type?(D.activeTexture(D.TEXTURE0+s[o]),"iTextTexture"===o?D.bindTexture(D.TEXTURE_2D,C):D.bindTexture(D.TEXTURE_2D,K[a.value].texture),D.uniform1i(n.locations[o],s[o])):r[a.type].call(D,n.locations[o],a.value)}D.bindVertexArray(P);var c=0*y[0].length;D.drawElements(D.TRIANGLES,R.length,D.UNSIGNED_SHORT,c);var l=D.getError();l!==D.NO_ERROR&&console.log(l),D.bindVertexArray(null),D.useProgram(null)},this.setSize=function(n,e){var t=D.canvas;t.width=n,t.height=e,D.viewport(0,0,n,e),K.forEach((function(t){D.deleteFramebuffer(t.frameBuffer),D.deleteTexture(t.texture),t.uniforms.iResolution.value=[n*t.scale,e*t.scale,0],B(t)}))},this.playSound=function(){q.audioSource.start(q.audioContext.currentTime,q.time%q.timeLength)},U=function(){return i(q,void 0,void 0,(function(){var e,t,i,a,r,s,c,f,m,E,u;return o(this,(function(o){switch(o.label){case 0:return e=Math.ceil(g.sampleRate*n),t=g.createBuffer(2,e,g.sampleRate),a=e/(i=262144),r=L(_),[4,A(100)];case 1:for(o.sent(),s=w(r,0,l,1),c=0;c<a;c++)for(s.uniforms.iBlockOffset.value=c*i/g.sampleRate,H(s),f=new Uint8Array(1048576),D.readPixels(0,0,512,512,D.RGBA,D.UNSIGNED_BYTE,f),m=t.getChannelData(0),E=t.getChannelData(1),u=0;u<i;u++)m[c*i+u]=(f[4*u+0]+256*f[4*u+1])/65535*2-1,E[c*i+u]=(f[4*u+2]+256*f[4*u+3])/65535*2-1;return this.audioSource=g.createBufferSource(),this.audioSource.buffer=t,this.audioSource.connect(g.destination),[2]}}))}))},this.render=function(){K.forEach((function(n){n.uniforms.iTime.value=q.time;for(var e=0,t=Object.entries(q.uniforms);e<t.length;e++){var i=t[e],o=i[0],a=i[1];void 0!==n.uniforms[o]&&(n.uniforms[o].value="number"==typeof a?a:[a[0]/255,a[1]/255,a[2]/255])}H(n)}))},(M=function(n){for(var e,t=/uniform (float|vec3) (g.+);\s*(\/\/ ([\-\d\.-]+))?( ([\-\d\.]+) ([\-\d\.]+))?( [\w\d]+)?/g;null!==(e=t.exec(n));){var i=void 0;i="float"===e[1]?{key:e[2],initValue:void 0!==e[4]?parseFloat(e[4]):0}:{key:e[2],initValue:[parseFloat(e[4]),parseFloat(e[6]),parseFloat(e[7])]},q.uniformArray.push(i),q.uniforms[i.key]=i.initValue}})(t),m.forEach((function(n){M(n)})),M(d),M(v),M(S),M(p),K=[],z=0,[4,i(q,void 0,void 0,(function(){var n,e,i,l,f,_,h,g=this;return o(this,(function(o){switch(o.label){case 0:n=0,o.label=1;case 1:if(!(n<m.length))return[3,4];if(e=m[n],n===E){for(K.push(w(L(t+d),z,s,1)),z++,i=1,l=0;l<u;l++)i*=.5,K.push(w(L(t+v),z,s,i)),z++;for(l=0;l<u-1;l++)i*=2,K.push(w(L(t+S),z,c,i)),z++;K.push(w(L(t+p),z,c,1)),z++}return K.push(w(L(t+e),z,n<m.length-1?a:r,1)),[4,A(100)];case 2:o.sent(),z++,o.label=3;case 3:return n++,[3,1];case 4:return[4,U()];case 5:return o.sent(),f=0,_=null,h=function(n){requestAnimationFrame(h),_||(_=n);var e=.001*(n-f);(g.isPlaying||g.needsUpdate)&&(null!=g.onRender&&g.onRender(g.time,e),g.render(),g.time=.001*(n-_)),g.needsUpdate=!1,f=n},this.play=function(){requestAnimationFrame(h)},[2]}}))}))]):(alert("need OES_texture_float_linear"),[2]):(alert("need EXT_color_buffer_float"),[2]):(console.log("WebGL 2 is not supported..."),[2]);case 1:return k.sent(),[2]}}))}))}},E=function(n,e,t){return n*(1-t)+e*t},u=function(n,e,t){return n<e?e:n>t?t:n},d=function(n){return u(n,0,1)},v=function(n,e,t,i,o){return function(n,e,t){return e<t?u(n,e,t):u(n,t,e)}(i+(n-e)*(o-i)/(t-e),i,o)},S=function(n,e,t){return v(n,e,t,0,1)},p=function(n,e){return Math.sin(n+e)+.5*Math.sin(2*n+e)+.25*Math.sin(4*n+e)},_=function(n){return n<.5?4*n*n*n:(n-1)*(2*n-2)*(2*n-2)+1},h=function(){function n(n,e,t){this.x=n,this.y=e,this.z=t}return n.prototype.add=function(e){return new n(this.x+e.x,this.y+e.y,this.z+e.z)},n.prototype.mul=function(e){return new n(this.x*e.x,this.y*e.y,this.z*e.z)},n.prototype.scale=function(e){return new n(this.x*e,this.y*e,this.z*e)},n.mix=function(e,t,i){return new n(E(e.x,t.x,i),E(e.y,t.y,i),E(e.z,t.z,i))},n.fbm=function(e){return new n(p(11431,e),p(23123,e),p(87034,e))},n}(),g=new m(109.714285714,t(0).default,t(1).default,[t(2).default,t(3).default,t(4).default,t(5).default],3,5,t(6).default,t(7).default,t(8).default,t(9).default,t(10).default,(function(n){var e=document.createElement("canvas"),t=e.getContext("2d");e.width=2048,e.height=4096,t.font="110px arial",t.textAlign="center",t.textBaseline="middle",t.fillStyle="white",t.clearRect(0,0,e.width,e.height),["A 64k INTRO","GRAPHICS","gam0022","MUSIC","sadakkey","RE: SIMULATED","REALITY","MERCURY","Ctrl-Alt-Test","RGBA & TBC","Fairlight","Conspiracy","Poo-Brain","kaneta","FMS_Cat","½-bit Cheese","Prismbeings","0x4015 & YET1","LJ & Alcatraz","logicoma","Polarity"].forEach((function(n,i){t.fillText(n,e.width/2,64+128*i)}));var i=n.createTexture();return n.bindTexture(n.TEXTURE_2D,i),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),i})),A=function(){function n(n){this.input=n,this.begin=0,this.done=!1}return n.prototype.then=function(n,e){return this.done||this.input<this.begin?this:this.input>=this.begin+n?(this.begin+=n,this):(e(this.input-this.begin),this.done=!0,this)},n.prototype.over=function(n){return this.done?this:(n(this.input-this.begin),this.done=!0,this)},n}(),T=0,D=1,x=2,b=3,N=4,y=5,R=function(n,e,t,i){return new(t||(t=Promise))((function(o,a){function r(n){try{c(i.next(n))}catch(n){a(n)}}function s(n){try{c(i.throw(n))}catch(n){a(n)}}function c(n){var e;n.done?o(n.value):(e=n.value,e instanceof t?e:new t((function(n){n(e)}))).then(r,s)}c((i=i.apply(n,e||[])).next())}))},F=function(n,e){var t,i,o,a,r={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(t)throw new TypeError("Generator is already executing.");for(;r;)try{if(t=1,i&&(o=2&a[0]?i.return:a[0]?i.throw||((o=i.return)&&o.call(i),0):i.next)&&!(o=o.call(i,a[1])).done)return o;switch(i=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return r.label++,{value:a[1],done:!1};case 5:r.label++,i=a[1],a=[0];continue;case 7:a=r.ops.pop(),r.trys.pop();continue;default:if(!(o=(o=r.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){r=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){r.label=a[1];break}if(6===a[0]&&r.label<o[1]){r.label=o[1],o=a;break}if(o&&r.label<o[2]){r.label=o[2],r.ops.push(a);break}o[2]&&r.ops.pop(),r.trys.pop();continue}a=e.call(n,r)}catch(n){a=[6,n],i=0}finally{t=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}};window.addEventListener("load",(function(n){var e=document.createElement("style");e.innerText=t(11).default,document.head.appendChild(e),document.addEventListener("fullscreenchange",(function(){document.body.style.cursor=window.document.fullscreenElement?"none":"auto"}));var i=document.createElement("div");i.className="container",document.body.appendChild(i);var o=document.createElement("p");i.appendChild(o),o.innerHTML="click to start",o.onclick=function(){o.remove();var n=document.createElement("p");n.innerHTML='Loading <div class="lds-facebook"><div></div><div></div><div></div></div>',i.appendChild(n),document.body.requestFullscreen().then((function(){return R(void 0,void 0,void 0,(function(){return F(this,(function(n){switch(n.label){case 0:return g.onRender=function(n,e){!function(n,e,t){var i=140*n/60,o=new h(0,0,10),a=new h(0,0,0),r=new h(0,0,-10);g.uniformArray.forEach((function(n){g.uniforms[n.key]=n.initValue})),new A(i).then(8,(function(n){g.uniforms.gBlend=-1+_(S(n,0,4)),g.uniforms.gTonemapExposure=.2,o=new h(0,.2,-13-.1*n).add(h.fbm(n).scale(.01)),a=new h(0,0,0),g.uniforms.gMandelboxScale=1.8,g.uniforms.gCameraLightIntensity=.4,g.uniforms.gEmissiveIntensity=0,g.uniforms.gSceneEps=.003,g.uniforms.gBallRadius=0})).then(8,(function(n){g.uniforms.gTonemapExposure=.2,o=new h(0,.2,-17-.1*n).add(h.fbm(n).scale(.01)),a=new h(0,0,0),g.uniforms.gMandelboxScale=1.8,g.uniforms.gCameraLightIntensity=1.2,g.uniforms.gEmissiveIntensity=0,g.uniforms.gBallRadius=0})).then(16,(function(n){o=new h(-.08503080276580499,1.3346599987007965,-15.01732922836809).add(h.fbm(n).scale(.001)),a=new h(.784904810273659,3.3444920877098543,7.36034431847018),g.uniforms.gCameraFov=(n<8?2:5)+.05*n,g.uniforms.gMandelboxScale=2.5010184112784057,g.uniforms.gCameraLightIntensity=1.4,g.uniforms.gEmissiveIntensity=0,g.uniforms.gSceneEps=.0002645177773046626,g.uniforms.gBallRadius=0})).then(16,(function(n){o=new h(.05336320223924196,3.2510840695253322+.01*n,-5.0872681523358665).add(h.fbm(n).scale(.001)),a=new h(-.21247566790275868,3.469965904363116,-.4828265949411093),g.uniforms.gCameraFov=22.457765885219057,g.uniforms.gMandelboxScale=2.9815487838971206,g.uniforms.gCameraLightIntensity=.01,g.uniforms.gEmissiveIntensity=1.8818642917049402,g.uniforms.gEdgeEps=1e-4,g.uniforms.gEmissiveSpeed=.5,g.uniforms.gBallRadius=0})).then(16,(function(n){o=new h(-.009156083313678657,3.548031114215368,.5*n-5.16851465075457).add(h.fbm(n).scale(.005)),a=o.add(new h(.1,.1,1)),g.uniforms.gCameraFov=23,g.uniforms.gMandelboxScale=2.9815487838971206,g.uniforms.gCameraLightIntensity=.003,g.uniforms.gEdgeEps=1e-4,g.uniforms.gEmissiveIntensity=1.8818642917049402,g.uniforms.gEmissiveSpeed=.5,g.uniforms.gBallRadius=0})).then(16,(function(n){var e=new h(0,2.8,-8),t=new h(0,0,-32);o=h.mix(e,t,d(.1*n)),a=new h(0,0,0),g.uniforms.gMandelboxScale=1+.02*n,g.uniforms.gEmissiveIntensity=6,g.uniforms.gBallRadius=0})).then(16,(function(n){r.z=-10-.2*n,o=new h(0,0,.2+.003*n*n).add(r).add(h.fbm(n).scale(.001)),a=r,g.uniforms.gMandelboxScale=1.32+0*Math.sin(n),g.uniforms.gEmissiveIntensity=6,g.uniforms.gBallRadius=.1})).then(8,(function(n){r.z=-10-.2*n,o=new h(-.2-.05*n,.2+.05*n,1+.05*n).add(r).add(h.fbm(n).scale(.001)),a=r,g.uniforms.gMandelboxScale=1.32-.02*n,g.uniforms.gEmissiveIntensity=6,g.uniforms.gBallRadius=.1})).then(8,(function(n){r.z=-10-.5*n,o=new h(1,-.2,-14).add(h.fbm(n).scale(.001)),a=r.add(new h(-.15,0,0)),g.uniforms.gMandelboxScale=1.244560757418114,g.uniforms.gEmissiveIntensity=6,g.uniforms.gBallRadius=.1})).then(8,(function(n){r.z=-10-.5*n,o=new h(.4,.5,-8).add(h.fbm(n).scale(.001)),a=r.add(new h(-.15,-.15,0)),g.uniforms.gMandelboxScale=1.244560757418114,g.uniforms.gEmissiveIntensity=6,g.uniforms.gBallRadius=.1})).then(8,(function(n){r.z=-10-.5*n,o=new h(0,0,-1).add(r).add(h.fbm(n).scale(.001)),a=r.add(new h(-.15,0,0)),g.uniforms.gCameraFov=43,g.uniforms.gMandelboxScale=1.2,g.uniforms.gEmissiveIntensity=6,g.uniforms.gBallRadius=.1,g.uniforms.gEmissiveHueShiftBeat=.5})).then(16,(function(n){r.z=-20,o=new h(0,0,-10).add(h.fbm(n).scale(.01)),a=o.add(new h(0,0,-1)),g.uniforms.gMandelboxScale=1.2-.01*n,g.uniforms.gEmissiveIntensity=6,g.uniforms.gBallRadius=.1,g.uniforms.gEmissiveHueShiftBeat=.5,g.uniforms.gEmissiveHueShiftZ=.3,g.uniforms.gEmissiveHueShiftXY=.3})).then(16,(function(n){r.z=10,o=new h(0,0,-8-2*n).add(h.fbm(n).scale(.01)),a=o.add(new h(0,0,1)),g.uniforms.gMandelboxScale=1.2-.0125*n,g.uniforms.gEmissiveIntensity=6,g.uniforms.gBallRadius=.1,g.uniforms.gFoldRotate=8,g.uniforms.gEmissiveHueShiftBeat=.5,g.uniforms.gEmissiveHueShiftZ=.3,g.uniforms.gEmissiveHueShiftXY=.3})).then(8,(function(n){if(r.z=-10-.2*n,o=new h(0,0,1+.003*n*n).add(r),a=r.scale(1),g.uniforms.gMandelboxScale=1.32-.04*n,g.uniforms.gEmissiveIntensity=6,g.uniforms.gBallRadius=.1,g.uniforms.gLogoIntensity=v(n,4,8,.02,2),n>=7){var e=Math.exp(-10*(n-7));g.uniforms.gShockDistortion=e,g.uniforms.gLogoIntensity+=e}g.uniforms.gF0=0,g.uniforms.gChromaticAberrationIntensity=.04+.1*d(Math.sin(2*Math.PI*n)),g.uniforms.gEmissiveHueShiftBeat=.3,g.uniforms.gEmissiveHueShiftXY=.3})).then(8,(function(n){if(r.z=-10-.2*n,o=new h(-.2-.1*n,.2+.02*n,1+.05*n).add(r).add(h.fbm(n).scale(.01)),a=r,g.uniforms.gCameraFov=v(n,0,8,13,20),g.uniforms.gBallDistortion=v(n,0,8,.01,.05),g.uniforms.gBallDistortionFreq=n<2?12:n<4?20:n<6?20+5*n:30,n>=4&&(g.uniforms.gInvertRate=Math.exp(-10*(n-4))),n>=7){var e=Math.exp(-10*(n-7));g.uniforms.gShockDistortion=e}g.uniforms.gEmissiveHueShiftBeat=.3,g.uniforms.gMandelboxScale=1.1,g.uniforms.gBallRadius=.1,g.uniforms.gLogoIntensity=1+Math.sin(n*Math.PI*2),g.uniforms.gF0=0,g.uniforms.gChromaticAberrationIntensity=.06+.1*Math.sin(10*n),g.uniforms.gEmissiveIntensity=6})).then(16,(function(n){r.z=-12-.2*n;var e=Math.exp(.3*-n);o=new h(.3*e,.3*e,2+.05*n).add(r).add(h.fbm(n).scale(.01)),a=r;var t=n%1;g.uniforms.gBallDistortion=v(n,0,8,.05,.1)*Math.exp(-5*t),g.uniforms.gBallDistortionFreq=n<2?12:n<4?20:n<6?10+5*n:n*n,n>=4&&(g.uniforms.gShockDistortion=4*Math.exp(-10*(n-4)),g.uniforms.gInvertRate=Math.exp(-10*(n-4))),n>=8&&(g.uniforms.gInvertRate=Math.exp(-20*(n-8))),g.uniforms.gExplodeDistortion=_(S(n,4,16)),g.uniforms.gBlend=_(S(n,13,16)),g.uniforms.gMandelboxScale=1.2,g.uniforms.gBallRadius=.1,g.uniforms.gEmissiveIntensity=6,g.uniforms.gChromaticAberrationIntensity=.04,g.uniforms.gEmissiveHue=.01,g.uniforms.gEmissiveHueShiftBeat=0,g.uniforms.gEmissiveHueShiftZ=S(n,4,16),g.uniforms.gEmissiveHueShiftXY=S(n,4,16)})).then(32,(function(n){g.uniforms.gSceneId=1,g.uniforms.gSceneEps=.002,g.uniforms.gTonemapExposure=1,a=new h(0,0,0),g.uniforms.gCameraFov=20*Math.exp(n%4*-.005),n<12?(g.uniforms.gPlanetsId=T,o=new h(-1.38,-.8550687112306142,47.4),g.uniforms.gCameraFov=20*Math.exp(-.005*n)):n<16?(g.uniforms.gPlanetsId=T,o=new h(5,1,30),g.uniforms.gCameraFov=13):n<20?(g.uniforms.gPlanetsId=D,o=new h(15,3,50),g.uniforms.gShockDistortion=.3*Math.exp(n%8*-20)):n<24?(g.uniforms.gPlanetsId=x,o=new h(15,1,20),n%4>3&&(g.uniforms.gGlitchIntensity=.05*Math.exp(n%4*-10))):n<28?(g.uniforms.gPlanetsId=b,o=new h(-15,3,20)):(g.uniforms.gPlanetsId=N,o=new h(-15,-3,50),g.uniforms.gShockDistortion=.3*Math.exp(n%8*-20)),o=o.scale(Math.exp(-.01*n)).add(h.fbm(n).scale(.01)),g.uniforms.gBallRadius=0,g.uniforms.gBloomIntensity=5,g.uniforms.gBloomThreshold=.7,g.uniforms.gBlend=v(n,0,8,1,0)})).then(32,(function(n){g.uniforms.gSceneId=1,g.uniforms.gPlanetsId=y,g.uniforms.gSceneEps=.005,g.uniforms.gTonemapExposure=1,o=new h(-47.38,-.85,12.4).scale(Math.exp(-.01*n)).add(h.fbm(n).scale(.01)),a=new h(0,0,0),r.z=0,g.uniforms.gCameraFov=30*Math.exp(-.01*n),(2<=n&&n<4||10<=n&&n<12||21<=n&&n<22||31<=n&&n<32)&&(g.uniforms.gGlitchIntensity=.05),g.uniforms.gBallRadius=0,g.uniforms.gBloomIntensity=5,g.uniforms.gBloomThreshold=.7})).over((function(n){g.uniforms.gBlend=-1})),g.uniforms.gBallZ=r.z,g.uniforms.gCameraEyeX=o.x,g.uniforms.gCameraEyeY=o.y,g.uniforms.gCameraEyeZ=o.z,g.uniforms.gCameraTargetX=a.x,g.uniforms.gCameraTargetY=a.y,g.uniforms.gCameraTargetZ=a.z}(n)},[4,g.init()];case 1:return n.sent(),window.addEventListener("resize",(function(){g.setSize(window.innerWidth,window.innerHeight)})),setTimeout((function(){i.remove(),g.play(),g.playSound()}),1e3),[2]}}))}))}))}}),!1)}]);